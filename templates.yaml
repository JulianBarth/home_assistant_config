# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright (c) 2024, Julian Bartholomeyczik
# All rights reserved.

# Battery Status Sensors
- sensor:
    - name: "Batterie SoC"
      unique_id: 884c1888-1880-4e98-923c-795ff9264af2
      icon: mdi:home-battery-outline
      unit_of_measurement: "%"
      device_class: battery
      state: >
        {{ ((states('sensor.reading_energy_battery_soc_scaled') | float) * (10 ** -2 )) | round(0)}}

    - name: "Charging State"
      unique_id: adf7fd02-94ac-4565-8392-c3b9d3b0d2dc
      state: >
        {% set mapper =  {
              '1' : 'OFF',
              '2' : 'EMPTY',
              '3' : 'DISCHARGING',
              '4' : 'CHARGING',
              '5' : 'FULL',
              '6' : 'HOLDING',
              '7' : 'TESTING'} %}
        {% set state =  states('sensor.ChaSt') %}
        {{ mapper[state] if state in mapper else 'Unknown' }}

# Binary sensors for solar forecast conditions
- binary_sensor:
    - name: "Expected Sun Low"
      unique_id: expected_sun_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float(default=50000) <= states('input_number.sun_threshold_low') | float(default=15000) }}

    - name: "Expected Sun Very Low"
      unique_id: expected_sun_very_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_forecast_next_x_hours') | float(default=50000) <= states('input_number.sun_threshold_very_low') | float(default=8000) }}

# Binary sensor for charging conditions
- binary_sensor:
    - name: "Should Start Charging"
      unique_id: should_start_charging
      state: >
        {# Guard: reject invalid SoC readings (Modbus glitch protection) #}
        {% set soc_state = states('sensor.reading_energy_battery_soc_scaled') %}
        {% if soc_state in ['unavailable', 'unknown'] or soc_state | float(default=0) <= 0 %}
          {{ false }}
        {% else %}
        {% set current_soc = soc_state | float(default=0) %}
        {% set target_soc = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set default_min = states('input_number.soc_target_default') | float(default=15) * 100 %}
        {% set automation_on = is_state('input_boolean.battery_automation_on', 'on') %}
        {% set charging_inactive = is_state('input_boolean.battery_charging_active', 'off') %}
        {% set hysteresis_buffer = states('input_number.soc_hist') | float(default=5) * 50 %}

        {# Only charge when algorithm actively wants to — computed_target must exceed #}
        {# the Fronius minimum. When computed_target = default, no charging is needed #}
        {# because Fronius handles min SoC natively. "Cheap" is relative to the day. #}
        {% set charging_justified = target_soc > default_min %}

        {# Check if car is charging - don't interfere with car protection #}
        {% set car_is_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}
        {% set car_protection_active = is_state('input_boolean.battery_no_discharging_active', 'on') %}

        {# Allow starting if: SoC below target AND charging is justified AND car is safe #}
        {% set basic_conditions = (current_soc < (target_soc - hysteresis_buffer)) and automation_on and charging_inactive and charging_justified %}
        {% set car_safe = not (car_is_charging and wallbox_not_eco and not car_protection_active) %}

        {{ basic_conditions and car_safe }}
        {% endif %}

    - name: "Should Stop Charging"
      unique_id: should_stop_charging
      state: >
        {# Guard: reject invalid SoC readings (Modbus glitch protection) #}
        {% set soc_state = states('sensor.reading_energy_battery_soc_scaled') %}
        {% if soc_state in ['unavailable', 'unknown'] or soc_state | float(default=0) <= 0 %}
          {{ false }}
        {% else %}
        {% set current_soc = soc_state | float(default=0) %}
        {% set target_soc = states('input_number.battery_target_soc') | float(default=100) * 100 %}
        {% set computed_target_soc = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set charging_active = is_state('input_boolean.battery_charging_active', 'on') %}

        {# Hysteresis: multiply by 50 to convert % to scaled SoC units #}
        {% set hysteresis = states('input_number.soc_hist') | float(default=5) * 50 %}

        {# Stop charging when: #}
        {# 1. Battery reaches the original target plus hysteresis OR #}
        {# 2. Battery exceeds the current computed target (respond immediately when prices increase) #}
        {% set reached_target = current_soc >= (target_soc + hysteresis) %}
        {% set exceeds_computed_target = current_soc >= computed_target_soc %}

        {{ (reached_target or exceeds_computed_target) and charging_active }}
        {% endif %}

    - name: "Should Hold Battery SOC"
      unique_id: should_hold_battery_soc
      icon: mdi:battery-lock
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float(default=0) %}
        {% set target_soc = states('input_number.battery_target_soc') | float(default=100) * 100 %}
        {% set charging_active = is_state('input_boolean.battery_charging_active', 'on') %}
        
        {# Hold threshold: configurable range around target (default ±3%) #}
        {% set hold_threshold = states('input_number.battery_hold_threshold') | float(default=3) * 100 %}
        
        {# Hold SOC when actively charging AND approaching target (within hold_threshold) #}
        {% set approaching_target = charging_active and (current_soc >= (target_soc - hold_threshold)) %}
        
        {{ approaching_target }}

    - name: "Should Prevent Discharge"
      unique_id: should_prevent_discharge
      icon: mdi:battery-lock-open
      state: >
        {# DISABLED: Fronius handles minimum reserve SoC natively #}
        {# HA algorithm only manages cost-optimized charging #}
        {{ false }}

# Stable car charging detection with hysteresis
- binary_sensor:
    - name: "Car Charging Stable"
      unique_id: car_charging_stable
      device_class: battery_charging
      icon: mdi:ev-station
      state: >
        {% set is_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}

        {% if not (is_charging and wallbox_not_eco) %}
          {{ false }}
        {% else %}
          {# Check if state has been stable for 3 minutes #}
          {% set last_changed = as_timestamp(states.sensor.wattpilot_carconnected.last_changed) %}
          {% set now_ts = as_timestamp(now()) %}
          {% set stable_seconds = 180 %}
          {{ (now_ts - last_changed) >= stable_seconds }}
        {% endif %}

    - name: "Solcast Update Due"
      unique_id: solcast_update_due
      state: >
        {% set nr = as_datetime(state_attr('sun.sun','next_rising')) | as_local %}
        {% set ns = as_datetime(state_attr('sun.sun','next_setting')) | as_local %}
        {% set api_request_limit = 10 %}
        {% if nr > ns %}
          {% set nr = nr - timedelta(hours = 24) %}
        {% endif %}
        {% set hours_difference = (ns - nr) %}
        {% set interval_hours = hours_difference / api_request_limit %}
        {% set ns = namespace(match = false) %}
        {% for i in range(api_request_limit) %}
          {% set start_time = nr + (i * interval_hours) %}
          {% if ((start_time - timedelta(seconds=30)) <= now()) and (now() <= (start_time + timedelta(seconds=30))) %}
            {% set ns.match = true %}
          {% endif %}
        {% endfor %}
        {{ ns.match }}

# Unified status sensor for monitoring
- sensor:
    - name: "Battery Control Status"
      unique_id: battery_control_status
      icon: mdi:state-machine
      state: >
        {% set charging = is_state('input_boolean.battery_charging_active', 'on') %}
        {% set discharge_limited = is_state('input_boolean.battery_no_discharging_active', 'on') %}
        {% set car_charging = is_state('binary_sensor.car_charging_stable', 'on') %}

        {% if charging and discharge_limited %}
          Charging (Car Protection Active)
        {% elif charging %}
          Charging (Normal)
        {% elif discharge_limited %}
          Discharge Limited (Car Charging)
        {% elif car_charging %}
          Car Charging (Waiting for Stable State)
        {% else %}
          Normal
        {% endif %}

# Computed target SoC sensor - Smart algorithm based on consumption patterns and solar forecast
    - name: "Battery Optimization Data"
      unique_id: battery_optimization_data
      icon: mdi:chart-timeline-variant
      state: >
        {# === CONFIGURATION INPUTS === #}
        {% set battery_capacity = states('input_number.battery_capacity_wh') | float(default=10000) %}
        {% set night_rate = states('input_number.night_consumption_rate_wh') | float(default=280) %}
        {% set day_rate = states('input_number.day_consumption_rate_wh') | float(default=850) %}
        {% set weekday_wake = states('input_number.weekday_wake_hour') | float(default=5.5) %}
        {% set weekend_wake = states('input_number.weekend_wake_hour') | float(default=7.5) %}
        {% set sleep_hour = states('input_number.sleep_hour') | float(default=22) %}
        {% set default_target = states('input_number.soc_target_default') | float(default=15) %}
        {% set round_trip_efficiency = 0.90 %}
        {% set max_price_cents = states('input_number.max_charge_price_cents') | float(default=25) %}
        {% set low_solar_threshold = states('input_number.low_solar_threshold_wh') | float(default=3000) %}
        
        {# === TIME CALCULATIONS === #}
        {% set current_hour = now().hour + (now().minute / 60) %}
        {% set is_weekend = now().weekday() >= 5 %}
        {% set wake_hour = weekend_wake if is_weekend else weekday_wake %}
        
        {# === PRICE CONDITIONS === #}
        {% set percentile = states('sensor.tibber_energy_price_percentile_next_12_hours') | float(default=100) %}
        {% set is_profitable = is_state('binary_sensor.battery_charging_is_profitable_enhanced', 'on') %}
        {% set current_price_eur = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set current_price_cents = current_price_eur * 100 %}
        {% set next_price_cents = states('sensor.tibber_energy_price_next_hour') | float(default=999) %}
        {% set price_drop_cents = next_price_cents - current_price_cents %}
        {% set is_falling_significantly = price_drop_cents < -1.5 %}
        {% set is_negative_price = current_price_eur < 0 %}
        {% set price_below_ceiling = current_price_cents < max_price_cents %}
        
        {# === SOLAR FORECAST === #}
        {% set expected_solar_wh = states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float(default=0) %}
        {% set current_soc = states('sensor.batterie_soc') | float(default=15) %}
        
        {# === SMART WINTER MODE (solar-forecast based) === #}
        {# When solar forecast is very low, ignore solar in calculations #}
        {% set is_low_solar_day = expected_solar_wh < low_solar_threshold %}
        {% set effective_solar = 0 if is_low_solar_day else expected_solar_wh %}
        
        {# === BRIDGE PERIOD CALCULATION === #}
        {# Only forecast hours the battery must cover until next energy source #}
        {# At night: bridge until wake (proxy for sunrise/solar start) #}
        {# During day: bridge until sleep, offset by remaining solar #}
        
        {% if current_hour < wake_hour %}
          {# Night (early morning): bridge until wake #}
          {% set bridge_hours = wake_hour - current_hour %}
          {% set bridge_consumption_wh = bridge_hours * night_rate %}
        {% elif current_hour < sleep_hour %}
          {# Day period: bridge until sleep #}
          {% set bridge_hours = sleep_hour - current_hour %}
          {% set bridge_consumption_wh = bridge_hours * day_rate %}
        {% else %}
          {# Night (after sleep): bridge until tomorrow wake #}
          {% set bridge_hours = (24 - current_hour) + wake_hour %}
          {% set bridge_consumption_wh = bridge_hours * night_rate %}
        {% endif %}
        
        {# === ENERGY DEFICIT === #}
        {# Subtract solar only during daytime (at night solar = 0) #}
        {% if current_hour >= wake_hour and current_hour < sleep_hour %}
          {% set usable_solar = effective_solar * round_trip_efficiency %}
        {% else %}
          {% set usable_solar = 0 %}
        {% endif %}
        {% set energy_deficit_wh = [bridge_consumption_wh - usable_solar, 0] | max %}
        {# Cap deficit at battery capacity — can't charge more than 100% #}
        {% set energy_deficit_wh = [energy_deficit_wh, battery_capacity] | min %}
        
        {# Convert deficit to SoC percentage #}
        {% set deficit_soc = (energy_deficit_wh / battery_capacity * 100) | round(0) %}
        {% set calculated_target = [default_target + deficit_soc, 100] | min %}
        
        {# === FINAL TARGET CALCULATION === #}
        {# Priority 1: Negative prices - always charge to 100% #}
        {% if is_negative_price %}
          100
        {# Priority 2: Price above ceiling - maintain minimum only #}
        {% elif not price_below_ceiling %}
          {{ default_target }}
        {# Priority 3: Not profitable to charge - maintain minimum #}
        {% elif not is_profitable %}
          {{ default_target }}
        {# Priority 4: Price falling significantly (>1.5ct) - wait unless already very cheap #}
        {% elif is_falling_significantly and percentile > 25 %}
          {{ default_target }}
        {# Priority 5: Very cheap prices (bottom 10%) - charge aggressively #}
        {% elif percentile <= 10 %}
          {{ [[calculated_target + 20, 100] | min, default_target] | max | round(0) }}
        {# Priority 6: Cheap prices (bottom 25%) - charge to full calculated target #}
        {% elif percentile <= 25 %}
          {{ [[calculated_target, 100] | min, default_target] | max | round(0) }}
        {# Priority 7: Moderate prices (bottom 50%) - charge 80% of target #}
        {% elif percentile <= 50 %}
          {% set adjusted_target = current_soc + (deficit_soc * 0.8) %}
          {{ [[adjusted_target, 90] | min, default_target] | max | round(0) }}
        {# Priority 8: Higher prices but significant deficit - conservative charging #}
        {% elif percentile <= 70 and energy_deficit_wh > (battery_capacity * 0.5) %}
          {% set adjusted_target = current_soc + (deficit_soc * 0.5) %}
          {{ [[adjusted_target, 70] | min, default_target] | max | round(0) }}
        {# Default: Expensive or no significant need - maintain minimum #}
        {% else %}
          {{ default_target }}
        {% endif %}
      attributes:
        calculation_data: >
          {# Debug view: recalculates bridge period + includes decision reason #}
          {% set battery_capacity = states('input_number.battery_capacity_wh') | float(default=10000) %}
          {% set night_rate = states('input_number.night_consumption_rate_wh') | float(default=280) %}
          {% set day_rate = states('input_number.day_consumption_rate_wh') | float(default=850) %}
          {% set weekday_wake = states('input_number.weekday_wake_hour') | float(default=5.5) %}
          {% set weekend_wake = states('input_number.weekend_wake_hour') | float(default=7.5) %}
          {% set sleep_hour = states('input_number.sleep_hour') | float(default=22) %}
          {% set low_solar_threshold = states('input_number.low_solar_threshold_wh') | float(default=3000) %}
          {% set max_price_cents = states('input_number.max_charge_price_cents') | float(default=25) %}
          {% set current_hour = now().hour + (now().minute / 60) %}
          {% set is_weekend = now().weekday() >= 5 %}
          {% set wake_hour = weekend_wake if is_weekend else weekday_wake %}
          {% set expected_solar_wh = states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float(default=0) %}
          {% set current_price_cents = states('sensor.tibber_energy_prices') | float(default=0) * 100 %}
          {% set next_price_cents = states('sensor.tibber_energy_price_next_hour') | float(default=999) %}
          {% set is_low_solar_day = expected_solar_wh < low_solar_threshold %}
          {% set effective_solar = 0 if is_low_solar_day else expected_solar_wh %}
          {% set percentile = states('sensor.tibber_energy_price_percentile_next_12_hours') | float(default=100) %}
          
          {% if current_hour < wake_hour %}
            {% set bridge_hours = wake_hour - current_hour %}
            {% set bridge_consumption = bridge_hours * night_rate %}
            {% set bridge_type = "night_to_wake" %}
          {% elif current_hour < sleep_hour %}
            {% set bridge_hours = sleep_hour - current_hour %}
            {% set bridge_consumption = bridge_hours * day_rate %}
            {% set bridge_type = "day_to_sleep" %}
          {% else %}
            {% set bridge_hours = (24 - current_hour) + wake_hour %}
            {% set bridge_consumption = bridge_hours * night_rate %}
            {% set bridge_type = "night_to_wake" %}
          {% endif %}
          
          {% if current_hour >= wake_hour and current_hour < sleep_hour %}
            {% set usable_solar = effective_solar * 0.9 %}
          {% else %}
            {% set usable_solar = 0 %}
          {% endif %}
          {% set deficit = [bridge_consumption - usable_solar, 0] | max %}
          {% set deficit = [deficit, battery_capacity] | min %}
          
          {% set price_drop = next_price_cents - current_price_cents %}
          {% set is_negative = current_price_cents < 0 %}
          {% set price_ok = current_price_cents < max_price_cents %}
          {% set is_profitable = is_state('binary_sensor.battery_charging_is_profitable_enhanced', 'on') %}
          {% set falling = price_drop < -1.5 %}
          
          {% if is_negative %}
            {% set reason = "Negative price: charge to 100%" %}
          {% elif not price_ok %}
            {% set reason = "Price above ceiling (" ~ max_price_cents ~ "ct)" %}
          {% elif not is_profitable %}
            {% set reason = "Not profitable to charge" %}
          {% elif falling and percentile > 25 %}
            {% set reason = "Waiting: price dropping " ~ (price_drop | round(1)) ~ "ct" %}
          {% elif percentile <= 10 %}
            {% set reason = "Bottom 10%: aggressive (+20%)" %}
          {% elif percentile <= 25 %}
            {% set reason = "Bottom 25%: full target" %}
          {% elif percentile <= 50 %}
            {% set reason = "Bottom 50%: 80% of target" %}
          {% elif percentile <= 70 %}
            {% set reason = "Bottom 70%: conservative (high deficit)" %}
          {% else %}
            {% set reason = "Price too high: minimum target" %}
          {% endif %}
          
          {
            "current_hour": {{ current_hour | round(1) }},
            "is_weekend": {{ is_weekend }},
            "wake_hour": {{ wake_hour }},
            "bridge_hours": {{ bridge_hours | round(1) }},
            "bridge_type": "{{ bridge_type }}",
            "bridge_consumption_wh": {{ bridge_consumption | round(0) }},
            "expected_solar_wh": {{ expected_solar_wh | round(0) }},
            "effective_solar_wh": {{ effective_solar | round(0) }},
            "usable_solar_wh": {{ usable_solar | round(0) }},
            "is_low_solar_day": {{ is_low_solar_day }},
            "energy_deficit_wh": {{ deficit | round(0) }},
            "current_price_cents": {{ current_price_cents | round(2) }},
            "next_price_cents": {{ next_price_cents | round(2) }},
            "price_drop_cents": {{ price_drop | round(2) }},
            "max_price_cents": {{ max_price_cents }},
            "price_percentile": {{ percentile }},
            "decision_reason": "{{ reason }}"
          }

    - name: "Computed Target SoC"
      unique_id: computed_target_soc
      unit_of_measurement: "%"
      icon: mdi:battery-charging-wireless
      state: >
        {{ states('sensor.battery_optimization_data') | float(default=15) }}
      attributes:
        debug_info: >
          {{ state_attr('sensor.battery_optimization_data', 'calculation_data') }}

# Balcony Power Plant (Balkonkraftwerk) Sensors
- sensor:
    - name: "Balkonkraftwerk Power"
      unique_id: balkonkraftwerk_power
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {{ states('sensor.inverter_power') | float(default=0) }}

    - name: "Balkonkraftwerk Daily Energy"
      unique_id: balkonkraftwerk_daily_energy
      icon: mdi:solar-panel
      unit_of_measurement: kWh
      device_class: energy
      state_class: total_increasing
      state: >
        {{ states('sensor.inverter_daily_energy') | float(default=0) }}

    - name: "Balkonkraftwerk Status"
      unique_id: balkonkraftwerk_status
      icon: mdi:state-machine
      state: >
        {% set power = states('sensor.inverter_power') | float(default=0) %}
        {% if power > 10 %}
          Producing
        {% elif power > 0 %}
          Idle
        {% else %}
          Offline
        {% endif %}

- binary_sensor:
    - name: "Balkonkraftwerk Online"
      unique_id: balkonkraftwerk_online
      device_class: connectivity
      state: >
        {% set power = states('sensor.inverter_power') %}
        {{ power not in ['unavailable', 'unknown', 'None'] }}

# Fronius Solar Production Sensors
- sensor:

    - name: "Fronius Solar Power"
      unique_id: fronius_solar_power
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set dc1 = states('sensor.fronius_dc_power_1') | float(default=0) %}
        {% set dc2 = states('sensor.fronius_dc_power_2') | float(default=0) %}
        {% set sf = states('sensor.fronius_dc_sf') | float(default=0) %}
        
        {% if dc1 == 65535 %} {% set dc1 = 0 %} {% endif %}
        {% if dc2 == 65535 %} {% set dc2 = 0 %} {% endif %}
        
        {% set total_dc = dc1 + dc2 %}
        
        {{ (total_dc * (10 ** sf)) | round(0) }}

    - name: "Fronius Debug"
      unique_id: fronius_debug
      state: >
        DC1: {{ states('sensor.fronius_dc_power_1') }}
        DC2: {{ states('sensor.fronius_dc_power_2') }}
        SF: {{ states('sensor.fronius_dc_sf') }}

    - name: "Total Solar Power"
      unique_id: total_solar_power
      icon: mdi:solar-power-variant
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      availability: >
        {{ states('sensor.fronius_solar_power') not in ['unavailable', 'unknown', none] 
           or states('sensor.inverter_power') not in ['unavailable', 'unknown', none] }}
      state: >
        {% set fronius = states('sensor.fronius_solar_power') | float(default=0) %}
        {% set deye = states('sensor.inverter_power') | float(default=0) %}
        {{ (fronius + deye) | round(0) }}

    - name: "Fronius Solar Status"
      unique_id: fronius_solar_status
      icon: mdi:state-machine
      availability: >
        {{ states('sensor.fronius_solar_power') not in ['unavailable', 'unknown', none] }}
      state: >
        {% set power = states('sensor.fronius_solar_power') | float(default=0) %}
        {% if power > 50 %}
          Producing
        {% elif power > 0 %}
          Low Production
        {% else %}
          Offline
        {% endif %}

- binary_sensor:
    - name: "Fronius Solar Online"
      unique_id: fronius_solar_online
      device_class: connectivity
      state: >
        {% set power = states('sensor.fronius_solar_power') %}
        {{ power not in ['unavailable', 'unknown', none] }}

# Unified battery control mode coordinator
- sensor:
    - name: "Battery Control Mode"
      unique_id: battery_control_mode
      icon: mdi:state-machine
      state: >
        {% set car_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}
        {% set should_charge = is_state('binary_sensor.should_start_charging', 'on') %}
        {% set is_charging = is_state('input_boolean.battery_charging_active', 'on') %}
        {% set should_stop = is_state('binary_sensor.should_stop_charging', 'on') %}
        {% set automation_on = is_state('input_boolean.battery_automation_on', 'on') %}
        {% set manual_charge = is_state('input_boolean.manual_battery_charge', 'on') %}
        {% set should_charge_during_car = is_state('binary_sensor.should_charge_battery_during_car_charging', 'on') %}

        {# Priority order: Manual > Car+Battery > Car Only > Battery > Normal #}
        {% if manual_charge %}
          manual_charging
        {% elif car_charging and wallbox_not_eco and automation_on %}
          {% if (should_charge or is_charging) and should_charge_during_car %}
            car_and_battery_charging
          {% else %}
            car_charging_only
          {% endif %}
        {% elif (should_charge or (is_charging and not should_stop)) and automation_on %}
          battery_charging
        {% else %}
          normal
        {% endif %}

# Smart decision for charging battery during car charging
- binary_sensor:
    - name: "Should Charge Battery During Car Charging"
      unique_id: should_charge_battery_during_car_charging
      icon: mdi:ev-station
      state: >
        {% set car_power = states('sensor.wattpilot_charging_power') | float(default=0) %}
        {% set home_power = states('sensor.home_consumption_power') | float(default=2000) %}
        {% set battery_charge_rate = states('input_number.battery_charge_rate_max') | float(default=5000) %}
        {% set grid_capacity = states('input_number.grid_connection_capacity') | float(default=20000) %}
        {% set current_price_cents = states('sensor.tibber_energy_prices') | float(default=999) * 100 %}
        {% set avg_price = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}

        {% set total_load = car_power + home_power + battery_charge_rate %}
        {% set load_ok = total_load < (grid_capacity * 0.9) %}
        {% set price_very_low = current_price_cents < (avg_price * 0.8) %}

        {{ load_ok and price_very_low }}

# Dynamic discharge limit based on price and battery level
- sensor:
    - name: "Discharge Limit Percentage"
      unique_id: discharge_limit_percentage
      unit_of_measurement: "%"
      icon: mdi:battery-arrow-down
      state: >
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set avg_price_cents = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}
        {% set avg_price = avg_price_cents / 100 %}
        {% set battery_soc = states('sensor.batterie_soc') | float(default=0) %}
        {% set car_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}

        {% if not car_charging %}
          100  {# No car charging: full discharge allowed #}
        {% elif current_price > (avg_price * 1.5) and battery_soc > 60 %}
          50  {# Very high prices + good battery: allow 50% discharge #}
        {% elif current_price > (avg_price * 1.2) and battery_soc > 40 %}
          30  {# High prices + decent battery: allow 30% discharge #}
        {% else %}
          10  {# Default during car charging: 10% limit #}
        {% endif %}

# Enhanced profitability calculation
- binary_sensor:
    - name: "Battery Charging Is Profitable Enhanced"
      unique_id: battery_charging_is_profitable_enhanced
      icon: mdi:cash-check
      state: >
        {% set current_price_cents = states('sensor.tibber_energy_prices') | float(default=999) * 100 %}
        {% set max_price_24h_cents = states('sensor.tibber_energy_highest_price_next_24_hours') | float(default=0) %}
        {% set avg_price_12h_cents = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}

        {# Guard: if price data unavailable, don't charge speculatively #}
        {% if max_price_24h_cents <= 0 or avg_price_12h_cents >= 999 %}
          false
        {% else %}
          {# System parameters (all values in Cent/kWh) #}
          {% set round_trip_efficiency = 0.90 %}
          {% set battery_wear_cost_cents = states('input_number.battery_wear_cost_per_kwh') | float(default=2) %}
          {% set min_spread_factor = 1.20 %}

          {# Effective costs #}
          {% set effective_charge_cost_cents = current_price_cents + battery_wear_cost_cents %}
          {% set effective_discharge_value_cents = max_price_24h_cents * round_trip_efficiency %}

          {# Profitable if: discharge value > charge cost * 1.2 AND current price < 85% of average #}
          {% set spread_sufficient = effective_discharge_value_cents > (effective_charge_cost_cents * min_spread_factor) %}
          {% set below_average = current_price_cents < (avg_price_12h_cents * 0.85) %}

          {{ spread_sufficient and below_average }}
        {% endif %}

# Energy Flow Sensors for Visualization
- sensor:
    - name: "Grid Power"
      unique_id: grid_power_flow
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set main_meter = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {{ main_meter | round(0) }}

    - name: "Battery Power"
      unique_id: battery_power_flow
      icon: mdi:battery
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        
        {# Estimate battery power based on energy balance #}
        {# Positive = charging, Negative = discharging #}
        {% if charging_state == 'CHARGING' %}
          {% set battery_power = (grid_power + solar_power - ac_output) | abs %}
          {{ battery_power | round(0) }}
        {% elif charging_state == 'DISCHARGING' %}
          {% set battery_power = -(ac_output - solar_power - grid_power) %}
          {{ battery_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "House Consumption"
      unique_id: house_consumption_power
      icon: mdi:home
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        {% set wallbox_power = states('sensor.wattpilot_charging_power') | float(default=0) %}
        
        {# House consumption = Total AC output - Wallbox consumption #}
        {% set house_consumption = ac_output - wallbox_power %}
        {{ [house_consumption, 0] | max | round(0) }}

    - name: "Solar To Battery"
      unique_id: solar_to_battery_flow
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        
        {% if charging_state == 'CHARGING' %}
          {# Solar available for battery charging #}
          {{ [solar_power, 0] | max | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Solar To House"
      unique_id: solar_to_house_flow
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        {% set wallbox_power = states('sensor.wattpilot_charging_power') | float(default=0) %}
        
        {# Calculate house consumption to avoid circular dependency #}
        {% set house_consumption = [ac_output - wallbox_power, 0] | max %}
        
        {% if charging_state in ['DISCHARGING', 'HOLDING', 'OFF'] %}
          {# Solar goes to house consumption - take minimum of both #}
          {{ [solar_power, house_consumption] | min | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Solar To Grid"
      unique_id: solar_to_grid_flow
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        
        {% if grid_power < 0 %}
          {# Negative grid = export #}
          {{ (grid_power | abs) | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Battery To House"
      unique_id: battery_to_house_flow
      icon: mdi:battery-arrow-up
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        
        {# Calculate battery power directly to avoid circular dependency #}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        
        {% if charging_state == 'DISCHARGING' %}
          {# Battery power when discharging #}
          {% set battery_power = -(ac_output - solar_power - grid_power) %}
          {{ (battery_power | abs) | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Grid To House"
      unique_id: grid_to_house_flow
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {% set charging_state = states('sensor.charging_state') %}
        
        {% if grid_power > 0 and charging_state != 'CHARGING' %}
          {# Positive grid = import for house #}
          {{ grid_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Grid To Battery"
      unique_id: grid_to_battery_flow
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {% set charging_state = states('sensor.charging_state') %}
        
        {% if grid_power > 0 and charging_state == 'CHARGING' %}
          {# Grid charging battery #}
          {{ grid_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Wallbox Power"
      unique_id: wallbox_power_consumption
      icon: mdi:ev-station
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {# Wrap Wattpilot sensor for consistency with other flow sensors #}
        {# Allows for future processing (e.g., filtering, smoothing) if needed #}
        {{ states('sensor.wattpilot_charging_power') | float(default=0) | round(0) }}

    # Helper Power Sensors for Energy Integration (Riemann Sum)
    - name: "Grid Import Power"
      unique_id: grid_import_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.grid_power') | float(default=0) %}
        {% if p > 0 %} {{ p }} {% else %} 0 {% endif %}

    - name: "Grid Export Power"
      unique_id: grid_export_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.grid_power') | float(default=0) %}
        {% if p < 0 %} {{ p | abs }} {% else %} 0 {% endif %}

    - name: "Battery Charge Power"
      unique_id: battery_charge_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.battery_power') | float(default=0) %}
        {% set state = states('sensor.charging_state') %}
        {% if state == 'CHARGING' %} {{ p | abs }} {% else %} 0 {% endif %}

    - name: "Battery Discharge Power"
      unique_id: battery_discharge_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.battery_power') | float(default=0) %}
        {% set state = states('sensor.charging_state') %}
        {% if state == 'DISCHARGING' %} {{ p | abs }} {% else %} 0 {% endif %}

# Sankey Chart Debug Sensors
# NOTE: Entity list is repeated in state and each attribute due to Home Assistant template limitations.
# When updating entities, update ALL occurrences of the list below.
- sensor:
    - name: "Sankey Battery Discharge"
      unique_id: sankey_battery_discharge
      icon: mdi:battery-arrow-down
      unit_of_measurement: W
      device_class: power
      state: >
        {% set battery_power = states('sensor.battery_power') | float(default=0) %}
        {% if battery_power < 0 %}
          {{ (battery_power | abs) | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Sankey Grid Import"
      unique_id: sankey_grid_import
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state: >
        {% set grid_power = states('sensor.grid_power') | float(default=0) %}
        {% if grid_power > 0 %}
          {{ grid_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Sankey Entity Check"
      unique_id: sankey_entity_check
      icon: mdi:chart-sankey-variant
      state: >
        {# ENTITY LIST - Keep in sync across all attributes #}
        {% set entities = [
          'sensor.total_solar_power',
          'sensor.sankey_grid_import',
          'sensor.sankey_battery_discharge',
          'sensor.solar_to_house',
          'sensor.solar_to_battery',
          'sensor.solar_to_grid',
          'sensor.grid_to_house',
          'sensor.grid_to_battery',
          'sensor.battery_to_house',
          'sensor.house_consumption'
        ] %}
        {% set numeric_pattern = '^-?\\d+\\.?\\d*$' %}
        {% set ns = namespace(unavailable=[], invalid=[]) %}
        {% for entity in entities %}
          {% if states(entity) in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
            {% set ns.unavailable = ns.unavailable + [entity] %}
          {% elif not (states(entity) | regex_match(numeric_pattern)) %}
            {% set ns.invalid = ns.invalid + [entity] %}
          {% endif %}
        {% endfor %}
        {% if ns.unavailable | length > 0 or ns.invalid | length > 0 %}
          ERROR
        {% else %}
          OK
        {% endif %}
      attributes:
        unavailable_entities: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {% set ns = namespace(unavailable=[]) %}
          {% for entity in entities %}
            {% if states(entity) in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
              {% set ns.unavailable = ns.unavailable + [entity] %}
            {% endif %}
          {% endfor %}
          {{ ns.unavailable }}
        invalid_entities: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {% set numeric_pattern = '^-?\\d+\\.?\\d*$' %}
          {% set ns = namespace(invalid=[]) %}
          {% for entity in entities %}
            {% if states(entity) not in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
              {% if not (states(entity) | regex_match(numeric_pattern)) %}
                {% set ns.invalid = ns.invalid + [entity] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.invalid }}
        total_entities: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {{ entities | length }}
        available_count: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {% set ns = namespace(available=0) %}
          {% for entity in entities %}
            {% if states(entity) not in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
              {% set ns.available = ns.available + 1 %}
            {% endif %}
          {% endfor %}
          {{ ns.available }}

    - name: "Sankey Debug Info"
      unique_id: sankey_debug_info
      icon: mdi:information-outline
      state: >
        {% set check_state = states('sensor.sankey_entity_check') %}
        {% if check_state == 'OK' %}
          All entities operational
        {% else %}
          Check entities panel for issues
        {% endif %}
      attributes:
        entity_states: >
          {
            "total_solar_power": "{{ states('sensor.total_solar_power') }}",
            "grid_power": "{{ states('sensor.grid_power') }}",
            "battery_power": "{{ states('sensor.battery_power') }}",
            "solar_to_house": "{{ states('sensor.solar_to_house') }}",
            "solar_to_battery": "{{ states('sensor.solar_to_battery') }}",
            "solar_to_grid": "{{ states('sensor.solar_to_grid') }}",
            "grid_to_house": "{{ states('sensor.grid_to_house') }}",
            "grid_to_battery": "{{ states('sensor.grid_to_battery') }}",
            "battery_to_house": "{{ states('sensor.battery_to_house') }}",
            "house_consumption": "{{ states('sensor.house_consumption') }}"
          }
        diagnosis: >
          {% set unavailable = state_attr('sensor.sankey_entity_check', 'unavailable_entities') %}
          {% set invalid = state_attr('sensor.sankey_entity_check', 'invalid_entities') %}
          {% if unavailable | length > 0 %}
            ISSUE: {{ unavailable | length }} entities are unavailable. Check their source sensors.
          {% elif invalid | length > 0 %}
            ISSUE: {{ invalid | length }} entities have invalid values. Check template calculations.
          {% else %}
            All entities are available and have valid numeric values.
          {% endif %}
        recommendations: >
          {% set unavailable = state_attr('sensor.sankey_entity_check', 'unavailable_entities') %}
          {% if 'sensor.total_solar_power' in unavailable or 'sensor.fronius_solar_power' in unavailable %}
            - Check Fronius Modbus connection (IP: 192.168.178.92)
          {% endif %}
          {% if 'sensor.balkonkraftwerk_power' in unavailable %}
            - Check Deye inverter connection (IP: 192.168.178.78)
          {% endif %}
          {% if 'sensor.grid_power' in unavailable %}
            - Check sensor.reading_energy_main_meter availability
          {% endif %}
          {% if 'sensor.battery_power' in unavailable %}
            - Check charging_state and energy sensors
          {% endif %}
          {% if unavailable | length == 0 %}
            No issues detected. Sankey chart should display correctly.
          {% endif %}

# ============================================================================
# Tibber Price Sensors (Migrated from deprecated platform: template syntax)
# ============================================================================
- sensor:
    - name: "Tibber Energy Lowest Price Next 24 Hours"
      unique_id: tibber_energy_lowest_price_next_24_hours
      unit_of_measurement: "Cent/kWh"
      icon: mdi:currency-eur
      state: >
        {% set current_time = now() %}
        {% set end_time = current_time + timedelta(hours=24) %}
        {% set today_prices = state_attr('sensor.tibber_energy_prices', 'today') %}
        {% set tomorrow_prices = state_attr('sensor.tibber_energy_prices', 'tomorrow') %}
        {% set combined_prices = (today_prices + tomorrow_prices) if today_prices and tomorrow_prices else today_prices %}

        {% if combined_prices %}
          {% set future_prices = combined_prices | selectattr('startsAt', '>=', current_time.isoformat()) | selectattr('startsAt', '<=', end_time.isoformat()) | list %}
          {% if future_prices | length > 0 %}
            {{ (future_prices | map(attribute='total') | min * 100) | round(2) }}
          {% else %}
            unknown
          {% endif %}
        {% else %}
          unknown
        {% endif %}

    - name: "Tibber Energy Lowest Price Next 12 Hours"
      unique_id: tibber_energy_lowest_price_next_12_hours
      unit_of_measurement: "Cent/kWh"
      icon: mdi:currency-eur
      state: >
        {% set current_time = now() %}
        {% set end_time = current_time + timedelta(hours=12) %}
        {% set today_prices = state_attr('sensor.tibber_energy_prices', 'today') %}
        {% set tomorrow_prices = state_attr('sensor.tibber_energy_prices', 'tomorrow') %}
        {% set combined_prices = (today_prices + tomorrow_prices) if today_prices and tomorrow_prices else today_prices %}

        {% if combined_prices %}
          {% set future_prices = combined_prices | selectattr('startsAt', '>=', current_time.isoformat()) | selectattr('startsAt', '<=', end_time.isoformat()) | list %}
          {% if future_prices | length > 0 %}
            {{ (future_prices | map(attribute='total') | min * 100) | round(2) }}
          {% else %}
            unknown
          {% endif %}
        {% else %}
          unknown
        {% endif %}

    - name: "Tibber Energy Price Next Hour"
      unique_id: tibber_energy_price_next_hour
      unit_of_measurement: "Cent/kWh"
      icon: mdi:currency-eur
      state: >
        {% set current_time = now() %}
        {% set today_prices = state_attr('sensor.tibber_energy_prices', 'today') %}
        {% set tomorrow_prices = state_attr('sensor.tibber_energy_prices', 'tomorrow') %}
        {% set combined_prices = (today_prices + tomorrow_prices) if today_prices and tomorrow_prices else today_prices %}

        {% if combined_prices %}
          {% set next_interval_prices = combined_prices | selectattr('startsAt', '>', current_time.isoformat()) | list %}
          {% if next_interval_prices | length > 0 %}
            {{ (next_interval_prices[0].total * 100) | round(2) }}
          {% else %}
            unknown
          {% endif %}
        {% else %}
          unknown
        {% endif %}

    - name: "Tibber Energy Highest Price Next 24 Hours"
      unique_id: tibber_energy_highest_price_next_24_hours
      unit_of_measurement: "Cent/kWh"
      icon: mdi:currency-eur
      state: >
        {% set current_time = now() %}
        {% set end_time = current_time + timedelta(hours=24) %}
        {% set today_prices = state_attr('sensor.tibber_energy_prices', 'today') %}
        {% set tomorrow_prices = state_attr('sensor.tibber_energy_prices', 'tomorrow') %}
        {% set combined_prices = (today_prices + tomorrow_prices) if today_prices and tomorrow_prices else today_prices %}

        {% if combined_prices %}
          {% set future_prices = combined_prices | selectattr('startsAt', '>=', current_time.isoformat()) | selectattr('startsAt', '<=', end_time.isoformat()) | list %}
          {% if future_prices | length > 0 %}
            {{ (future_prices | map(attribute='total') | max * 100) | round(2) }}
          {% else %}
            unknown
          {% endif %}
        {% else %}
          unknown
        {% endif %}

    - name: "Tibber Energy Average Price Next 12 Hours"
      unique_id: tibber_energy_average_price_next_12_hours
      unit_of_measurement: "Cent/kWh"
      icon: mdi:currency-eur
      state: >
        {% set current_time = now() %}
        {% set end_time = current_time + timedelta(hours=12) %}
        {% set today_prices = state_attr('sensor.tibber_energy_prices', 'today') %}
        {% set tomorrow_prices = state_attr('sensor.tibber_energy_prices', 'tomorrow') %}
        {% set combined_prices = (today_prices + tomorrow_prices) if today_prices and tomorrow_prices else today_prices %}

        {% if combined_prices %}
          {% set future_prices = combined_prices | selectattr('startsAt', '>=', current_time.isoformat()) | selectattr('startsAt', '<=', end_time.isoformat()) | list %}
          {% if future_prices | length > 0 %}
            {{ ((future_prices | map(attribute='total') | sum) / (future_prices | length) * 100) | round(2) }}
          {% else %}
            unknown
          {% endif %}
        {% else %}
          unknown
        {% endif %}

    - name: "Tibber Energy Price Percentile Next 12 Hours"
      unique_id: tibber_energy_price_percentile_next_12_hours
      unit_of_measurement: "%"
      icon: mdi:percent
      state: >
        {% set current_time = now() %}
        {% set end_time = current_time + timedelta(hours=12) %}
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set today_prices = state_attr('sensor.tibber_energy_prices', 'today') %}
        {% set tomorrow_prices = state_attr('sensor.tibber_energy_prices', 'tomorrow') %}
        {% set combined_prices = (today_prices + tomorrow_prices) if today_prices and tomorrow_prices else today_prices %}

        {% if combined_prices and current_price != 'unknown' %}
          {# Include current interval by looking back 15 minutes #}
          {% set window_start = current_time - timedelta(minutes=15) %}
          {% set window_prices = combined_prices | selectattr('startsAt', '>=', window_start.isoformat()) | selectattr('startsAt', '<=', end_time.isoformat()) | map(attribute='total') | list %}
          {% if window_prices | length > 0 %}
            {% set lower_count = window_prices | select('<', current_price) | list | length %}
            {{ ((lower_count / window_prices | length) * 100) | round(0) }}
          {% else %}
            unknown
          {% endif %}
        {% else %}
          unknown
        {% endif %}

# ============================================================================
# Price Binary Sensors (Migrated from deprecated platform: template syntax)
# ============================================================================
- binary_sensor:
    - name: "Price Is Lowest"
      unique_id: price_is_lowest
      icon: mdi:cash-minus
      state: >
        {% set lowest_price_24_hours = states('sensor.tibber_energy_lowest_price_next_24_hours') | float(default=999) %}
        {% set current_price = (states('sensor.tibber_energy_prices') | float(default=999)) * 100 %}
        {% set price_tolerance = 3 %}
        {% if lowest_price_24_hours > (current_price - price_tolerance) and is_state('binary_sensor.price_is_lower_than_next_hour', 'on') %}
          true
        {% else %}
          false
        {% endif %}

    - name: "Price Is Lower Than Next Interval"
      unique_id: price_is_lower_than_next_hour
      icon: mdi:arrow-down-bold
      state: >
        {% if states('sensor.tibber_energy_price_next_hour') | float(default=999) > (((states('sensor.tibber_energy_prices') | float(default=999))*100)) %}
          true
        {% else %}
          false
        {% endif %}

    - name: "Price Is Lowest 12 Hours"
      unique_id: price_is_lowest_12_hours
      icon: mdi:cash-minus
      state: >
        {% set lowest_price_12_hours = states('sensor.tibber_energy_lowest_price_next_12_hours') | float(default=999) %}
        {% set current_price = (states('sensor.tibber_energy_prices') | float(default=999)) * 100 %}
        {% set price_tolerance = 3 %}
        {% if lowest_price_12_hours > (current_price - price_tolerance) and is_state('binary_sensor.price_is_lower_than_next_hour', 'on') %}
          true
        {% else %}
          false
        {% endif %}

    - name: "Price in Bottom 25%"
      unique_id: price_is_in_bottom_25_percent
      icon: mdi:percent-box
      state: >
        {% set percentile = states('sensor.tibber_energy_price_percentile_next_12_hours') | float(default=100) %}
        {{ percentile <= 25 }}

    - name: "Tibber Pulse Not Functioning"
      unique_id: tibber_pulse_not_functioning
      device_class: problem
      icon: mdi:alert-circle
      state: >
        {{ states('sensor.tibber_pulse_luftehutte_stromerzeugung') in ['unavailable', 'unknown', 'None'] }}
