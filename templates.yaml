# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright (c) 2024, Julian Bartholomeyczik
# All rights reserved.

# Battery Status Sensors
- sensor:
    - name: "Batterie SoC"
      unique_id: 884c1888-1880-4e98-923c-795ff9264af2
      icon: mdi:home-battery-outline
      unit_of_measurement: "%"
      device_class: battery
      state: >
        {{ ((states('sensor.reading_energy_battery_soc_scaled') | float) * (10 ** -2 )) | round(0)}}

    - name: "Charging State"
      unique_id: adf7fd02-94ac-4565-8392-c3b9d3b0d2dc
      state: >
        {% set mapper =  {
              '1' : 'OFF',
              '2' : 'EMPTY',
              '3' : 'DISCHARGING',
              '4' : 'CHARGING',
              '5' : 'FULL',
              '6' : 'HOLDING',
              '7' : 'TESTING'} %}
        {% set state =  states('sensor.ChaSt') %}
        {{ mapper[state] if state in mapper else 'Unknown' }}

# Binary sensors for solar forecast conditions
- binary_sensor:
    - name: "Expected Sun Low"
      unique_id: expected_sun_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float(default=50000) <= states('input_number.sun_threshold_low') | float(default=15000) }}

    - name: "Expected Sun Very Low"
      unique_id: expected_sun_very_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_forecast_next_x_hours') | float(default=50000) <= states('input_number.sun_threshold_very_low') | float(default=8000) }}

# Binary sensor for charging conditions
- binary_sensor:
    - name: "Should Start Charging"
      unique_id: should_start_charging
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float(default=0) %}
        {% set target_soc = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set automation_on = is_state('input_boolean.battery_automation_on', 'on') %}
        {% set charging_inactive = is_state('input_boolean.battery_charging_active', 'off') %}
        {% set hysteresis_buffer = states('input_number.soc_hist') | float(default=5) * 50 %}

        {# Check if car is charging - don't interfere with car protection #}
        {% set car_is_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}
        {% set car_protection_active = is_state('input_boolean.battery_no_discharging_active', 'on') %}

        {# Allow starting if: normal conditions met AND (car not charging OR car protection already handled) #}
        {% set basic_conditions = (current_soc < (target_soc - hysteresis_buffer)) and automation_on and charging_inactive %}
        {% set car_safe = not (car_is_charging and wallbox_not_eco and not car_protection_active) %}

        {{ basic_conditions and car_safe }}

    - name: "Should Stop Charging"
      unique_id: should_stop_charging
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float(default=0) %}
        {% set target_soc = states('input_number.battery_target_soc') | float(default=100) * 100 %}
        {% set computed_target_soc = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set charging_active = is_state('input_boolean.battery_charging_active', 'on') %}

        {# Hysteresis: multiply by 50 to convert % to scaled SoC units #}
        {% set hysteresis = states('input_number.soc_hist') | float(default=5) * 50 %}

        {# Stop charging when: #}
        {# 1. Battery reaches the original target plus hysteresis OR #}
        {# 2. Battery exceeds the current computed target (respond immediately when prices increase) #}
        {% set reached_target = current_soc >= (target_soc + hysteresis) %}
        {% set exceeds_computed_target = current_soc >= computed_target_soc %}

        {{ (reached_target or exceeds_computed_target) and charging_active }}

    - name: "Should Hold Battery SOC"
      unique_id: should_hold_battery_soc
      icon: mdi:battery-lock
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float(default=0) %}
        {# Default 100 represents maximum target (100% SOC) as fallback #}
        {% set target_soc = states('input_number.battery_target_soc') | float(default=100) * 100 %}
        {% set computed_target = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set charging_active = is_state('input_boolean.battery_charging_active', 'on') %}
        
        {# Hold threshold: configurable range around target (default ±3%) #}
        {% set hold_threshold = states('input_number.battery_hold_threshold') | float(default=3) * 100 %}
        
        {# Hysteresis for stop charging #}
        {% set stop_hysteresis = states('input_number.soc_hist') | float(default=5) * 50 %}
        
        {# Hold SOC when: Battery is within ±3% of target AND charging was active #}
        {% set at_target = (current_soc >= (target_soc - hold_threshold)) and (current_soc <= (target_soc + hold_threshold)) %}
        {% set below_stop_threshold = current_soc < (target_soc + stop_hysteresis) %}
        
        {{ at_target and below_stop_threshold and charging_active }}

    - name: "Should Prevent Discharge"
      unique_id: should_prevent_discharge
      icon: mdi:battery-lock-open
      state: >
        {# Prevent discharging when battery is at or near computed target SoC #}
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float(default=0) %}
        {% set computed_target = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set charging_active = is_state('input_boolean.battery_charging_active', 'on') %}
        {% set hold_active = is_state('binary_sensor.should_hold_battery_soc', 'on') %}
        
        {# Buffer zone: prevent discharge if within configurable buffer above target #}
        {% set buffer = states('input_number.battery_discharge_buffer') | float(default=5) * 100 %}
        {% set at_or_near_target = (current_soc >= computed_target) and (current_soc <= (computed_target + buffer)) %}
        
        {# Prevent discharge when: at target and (charging was active OR hold mode active) #}
        {{ at_or_near_target and (charging_active or hold_active) }}

# Stable car charging detection with hysteresis
- binary_sensor:
    - name: "Car Charging Stable"
      unique_id: car_charging_stable
      device_class: battery_charging
      icon: mdi:ev-station
      state: >
        {% set is_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}

        {% if not (is_charging and wallbox_not_eco) %}
          {{ false }}
        {% else %}
          {# Check if state has been stable for 3 minutes #}
          {% set last_changed = as_timestamp(states.sensor.wattpilot_carconnected.last_changed) %}
          {% set now_ts = as_timestamp(now()) %}
          {% set stable_seconds = 180 %}
          {{ (now_ts - last_changed) >= stable_seconds }}
        {% endif %}

    - name: "Solcast Update Due"
      unique_id: solcast_update_due
      state: >
        {% set nr = as_datetime(state_attr('sun.sun','next_rising')) | as_local %}
        {% set ns = as_datetime(state_attr('sun.sun','next_setting')) | as_local %}
        {% set api_request_limit = 10 %}
        {% if nr > ns %}
          {% set nr = nr - timedelta(hours = 24) %}
        {% endif %}
        {% set hours_difference = (ns - nr) %}
        {% set interval_hours = hours_difference / api_request_limit %}
        {% set ns = namespace(match = false) %}
        {% for i in range(api_request_limit) %}
          {% set start_time = nr + (i * interval_hours) %}
          {% if ((start_time - timedelta(seconds=30)) <= now()) and (now() <= (start_time + timedelta(seconds=30))) %}
            {% set ns.match = true %}
          {% endif %}
        {% endfor %}
        {{ ns.match }}

# Unified status sensor for monitoring
- sensor:
    - name: "Battery Control Status"
      unique_id: battery_control_status
      icon: mdi:state-machine
      state: >
        {% set charging = is_state('input_boolean.battery_charging_active', 'on') %}
        {% set discharge_limited = is_state('input_boolean.battery_no_discharging_active', 'on') %}
        {% set car_charging = is_state('binary_sensor.car_charging_stable', 'on') %}

        {% if charging and discharge_limited %}
          Charging (Car Protection Active)
        {% elif charging %}
          Charging (Normal)
        {% elif discharge_limited %}
          Discharge Limited (Car Charging)
        {% elif car_charging %}
          Car Charging (Waiting for Stable State)
        {% else %}
          Normal
        {% endif %}

# Computed target SoC sensor - Smart algorithm based on consumption patterns and solar forecast
    - name: "Battery Optimization Data"
      unique_id: battery_optimization_data
      icon: mdi:chart-timeline-variant
      state: >
        {# === CONFIGURATION INPUTS === #}
        {% set battery_capacity = states('input_number.battery_capacity_wh') | float(default=10000) %}
        {% set night_rate = states('input_number.night_consumption_rate_wh') | float(default=150) %}
        {% set day_rate = states('input_number.day_consumption_rate_wh') | float(default=530) %}
        {% set weekday_wake = states('input_number.weekday_wake_hour') | float(default=5.5) %}
        {% set weekend_wake = states('input_number.weekend_wake_hour') | float(default=7.5) %}
        {% set sleep_hour = states('input_number.sleep_hour') | float(default=22) %}
        {% set default_target = states('input_number.soc_target_default') | float(default=15) %}
        {% set round_trip_efficiency = 0.90 %}
        
        {# === TIME CALCULATIONS === #}
        {% set current_hour = now().hour + (now().minute / 60) %}
        {% set is_weekend = now().weekday() >= 5 %}
        {% set wake_hour = weekend_wake if is_weekend else weekday_wake %}
        
        {# === PRICE CONDITIONS === #}
        {% set percentile = states('sensor.tibber_energy_price_percentile_next_12_hours') | float(default=100) %}
        {% set is_profitable = is_state('binary_sensor.battery_charging_is_profitable_enhanced', 'on') %}
        {% set current_price_eur = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set next_price_cents = states('sensor.tibber_energy_price_next_hour') | float(default=999) %}
        {% set is_falling = next_price_cents < (current_price_eur * 100) %}
        
        {# === SOLAR FORECAST === #}
        {% set expected_solar_wh = states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float(default=0) %}
        {% set current_soc = states('sensor.batterie_soc') | float(default=15) %}
        
        {# === CALCULATE HOURS UNTIL END OF DAY CYCLES === #}
        {# Night period: current → wake_hour (if before wake) OR sleep_hour → midnight → wake_hour #}
        {# Day period: wake_hour → sleep_hour #}
        
        {% if current_hour < wake_hour %}
          {# Currently in night period (early morning before wake) #}
          {% set night_hours_remaining = wake_hour - current_hour %}
          {% set day_hours_remaining = sleep_hour - wake_hour %}
        {% elif current_hour < sleep_hour %}
          {# Currently in day period #}
          {% set night_hours_remaining = 0 %}
          {% set day_hours_remaining = sleep_hour - current_hour %}
        {% else %}
          {# Currently in night period (after sleep_hour) → calculate until tomorrow wake #}
          {% set night_hours_remaining = (24 - current_hour) + wake_hour %}
          {% set day_hours_remaining = sleep_hour - wake_hour %}
        {% endif %}
        
        {# === CONSUMPTION CALCULATION === #}
        {% set expected_consumption_wh = (night_hours_remaining * night_rate) + (day_hours_remaining * day_rate) %}
        
        {# === ENERGY DEFICIT === #}
        {# Energy needed = consumption - solar, accounting for battery efficiency #}
        {% set usable_solar = expected_solar_wh * round_trip_efficiency %}
        {% set energy_deficit_wh = expected_consumption_wh - usable_solar %}
        
        {# Convert deficit to SoC percentage #}
        {% set deficit_soc = (energy_deficit_wh / battery_capacity * 100) | round(0) %}
        {% set calculated_target = default_target + deficit_soc %}
        
        {# === FINAL TARGET CALCULATION === #}
        {% if not is_profitable %}
          {# Not profitable to charge: maintain minimum #}
          {{ default_target }}
        {% elif is_falling %}
          {# Price is falling: don't charge now, wait for cheaper prices #}
          {{ default_target }}
        {% elif percentile <= 20 %}
          {# Very cheap: charge to calculated target (capped at 100%) #}
          {{ [[calculated_target, 100] | min, default_target] | max | round(0) }}
        {% elif percentile <= 40 %}
          {# Moderately cheap: charge to 80% of calculated target #}
          {% set adjusted_target = current_soc + (deficit_soc * 0.8) %}
          {{ [[adjusted_target, 90] | min, default_target] | max | round(0) }}
        {% elif percentile <= 60 and energy_deficit_wh > (battery_capacity * 0.3) %}
          {# Mid-range price but significant deficit: charge conservatively #}
          {% set adjusted_target = current_soc + (deficit_soc * 0.5) %}
          {{ [[adjusted_target, 70] | min, default_target] | max | round(0) }}
        {% else %}
          {# Expensive or no significant need: maintain minimum #}
          {{ default_target }}
        {% endif %}
      attributes:
        calculation_data: >
          {# Re-calculating essential vars for debug view #}
          {# Note: Limited duplication remains unavoidable in standard templates for attributes #}
          {% set battery_capacity = states('input_number.battery_capacity_wh') | float(default=10000) %}
          {% set night_rate = states('input_number.night_consumption_rate_wh') | float(default=150) %}
          {% set day_rate = states('input_number.day_consumption_rate_wh') | float(default=530) %}
          {% set weekday_wake = states('input_number.weekday_wake_hour') | float(default=5.5) %}
          {% set weekend_wake = states('input_number.weekend_wake_hour') | float(default=7.5) %}
          {% set sleep_hour = states('input_number.sleep_hour') | float(default=22) %}
          {% set current_hour = now().hour + (now().minute / 60) %}
          {% set is_weekend = now().weekday() >= 5 %}
          {% set wake_hour = weekend_wake if is_weekend else weekday_wake %}
          {% set expected_solar_wh = states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float(default=0) %}
          
          {% if current_hour < wake_hour %}
            {% set night_hours = wake_hour - current_hour %}
            {% set day_hours = sleep_hour - wake_hour %}
          {% elif current_hour < sleep_hour %}
            {% set night_hours = 0 %}
            {% set day_hours = sleep_hour - current_hour %}
          {% else %}
            {% set night_hours = (24 - current_hour) + wake_hour %}
            {% set day_hours = sleep_hour - wake_hour %}
          {% endif %}
          
          {% set consumption = (night_hours * night_rate) + (day_hours * day_rate) %}
          {% set deficit = consumption - (expected_solar_wh * 0.9) %}
          
          {
            "current_hour": {{ current_hour | round(1) }},
            "is_weekend": {{ is_weekend }},
            "wake_hour": {{ wake_hour }},
            "night_hours_remaining": {{ night_hours | round(1) }},
            "day_hours_remaining": {{ day_hours | round(1) }},
            "expected_consumption_wh": {{ consumption | round(0) }},
            "expected_solar_wh": {{ expected_solar_wh | round(0) }},
            "energy_deficit_wh": {{ deficit | round(0) }},
            "price_percentile": {{ states('sensor.tibber_energy_price_percentile_next_12_hours') }}
          }

    - name: "Computed Target SoC"
      unique_id: computed_target_soc
      unit_of_measurement: "%"
      icon: mdi:battery-charging-wireless
      state: >
        {{ states('sensor.battery_optimization_data') | float(default=15) }}
      attributes:
        debug_info: >
          {{ state_attr('sensor.battery_optimization_data', 'calculation_data') }}

# Balcony Power Plant (Balkonkraftwerk) Sensors
- sensor:
    - name: "Balkonkraftwerk Power"
      unique_id: balkonkraftwerk_power
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {{ states('sensor.inverter_power') | float(default=0) }}

    - name: "Balkonkraftwerk Daily Energy"
      unique_id: balkonkraftwerk_daily_energy
      icon: mdi:solar-panel
      unit_of_measurement: kWh
      device_class: energy
      state_class: total_increasing
      state: >
        {{ states('sensor.inverter_daily_energy') | float(default=0) }}

    - name: "Balkonkraftwerk Status"
      unique_id: balkonkraftwerk_status
      icon: mdi:state-machine
      state: >
        {% set power = states('sensor.inverter_power') | float(default=0) %}
        {% if power > 10 %}
          Producing
        {% elif power > 0 %}
          Idle
        {% else %}
          Offline
        {% endif %}

- binary_sensor:
    - name: "Balkonkraftwerk Online"
      unique_id: balkonkraftwerk_online
      device_class: connectivity
      state: >
        {% set power = states('sensor.inverter_power') %}
        {{ power not in ['unavailable', 'unknown', 'None'] }}

# Fronius Solar Production Sensors
- sensor:

    - name: "Fronius Solar Power"
      unique_id: fronius_solar_power
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set dc1 = states('sensor.fronius_dc_power_1') | float(default=0) %}
        {% set dc2 = states('sensor.fronius_dc_power_2') | float(default=0) %}
        {% set sf = states('sensor.fronius_dc_sf') | float(default=0) %}
        
        {% if dc1 == 65535 %} {% set dc1 = 0 %} {% endif %}
        {% if dc2 == 65535 %} {% set dc2 = 0 %} {% endif %}
        
        {% set total_dc = dc1 + dc2 %}
        
        {{ (total_dc * (10 ** sf)) | round(0) }}

    - name: "Fronius Debug"
      unique_id: fronius_debug
      state: >
        DC1: {{ states('sensor.fronius_dc_power_1') }}
        DC2: {{ states('sensor.fronius_dc_power_2') }}
        SF: {{ states('sensor.fronius_dc_sf') }}

    - name: "Total Solar Power"
      unique_id: total_solar_power
      icon: mdi:solar-power-variant
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      availability: >
        {{ states('sensor.fronius_solar_power') not in ['unavailable', 'unknown', none] 
           or states('sensor.inverter_power') not in ['unavailable', 'unknown', none] }}
      state: >
        {% set fronius = states('sensor.fronius_solar_power') | float(default=0) %}
        {% set deye = states('sensor.inverter_power') | float(default=0) %}
        {{ (fronius + deye) | round(0) }}

    - name: "Fronius Solar Status"
      unique_id: fronius_solar_status
      icon: mdi:state-machine
      availability: >
        {{ states('sensor.fronius_solar_power') not in ['unavailable', 'unknown', none] }}
      state: >
        {% set power = states('sensor.fronius_solar_power') | float(default=0) %}
        {% if power > 50 %}
          Producing
        {% elif power > 0 %}
          Low Production
        {% else %}
          Offline
        {% endif %}

- binary_sensor:
    - name: "Fronius Solar Online"
      unique_id: fronius_solar_online
      device_class: connectivity
      state: >
        {% set power = states('sensor.fronius_solar_power') %}
        {{ power not in ['unavailable', 'unknown', none] }}

# Unified battery control mode coordinator
- sensor:
    - name: "Battery Control Mode"
      unique_id: battery_control_mode
      icon: mdi:state-machine
      state: >
        {% set car_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}
        {% set should_charge = is_state('binary_sensor.should_start_charging', 'on') %}
        {% set is_charging = is_state('input_boolean.battery_charging_active', 'on') %}
        {% set should_stop = is_state('binary_sensor.should_stop_charging', 'on') %}
        {% set automation_on = is_state('input_boolean.battery_automation_on', 'on') %}
        {% set manual_charge = is_state('input_boolean.manual_battery_charge', 'on') %}
        {% set should_charge_during_car = is_state('binary_sensor.should_charge_battery_during_car_charging', 'on') %}

        {# Priority order: Manual > Car+Battery > Car Only > Battery > Normal #}
        {% if manual_charge %}
          manual_charging
        {% elif car_charging and wallbox_not_eco and automation_on %}
          {% if (should_charge or is_charging) and should_charge_during_car %}
            car_and_battery_charging
          {% else %}
            car_charging_only
          {% endif %}
        {% elif (should_charge or (is_charging and not should_stop)) and automation_on %}
          battery_charging
        {% else %}
          normal
        {% endif %}

# Smart decision for charging battery during car charging
- binary_sensor:
    - name: "Should Charge Battery During Car Charging"
      unique_id: should_charge_battery_during_car_charging
      icon: mdi:ev-station
      state: >
        {% set car_power = states('sensor.wattpilot_charging_power') | float(default=0) %}
        {% set home_power = states('sensor.home_consumption_power') | float(default=2000) %}
        {% set battery_charge_rate = states('input_number.battery_charge_rate_max') | float(default=5000) %}
        {% set grid_capacity = states('input_number.grid_connection_capacity') | float(default=20000) %}
        {% set current_price_cents = states('sensor.tibber_energy_prices') | float(default=999) * 100 %}
        {% set avg_price = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}

        {% set total_load = car_power + home_power + battery_charge_rate %}
        {% set load_ok = total_load < (grid_capacity * 0.9) %}
        {% set price_very_low = current_price_cents < (avg_price * 0.8) %}

        {{ load_ok and price_very_low }}

# Dynamic discharge limit based on price and battery level
- sensor:
    - name: "Discharge Limit Percentage"
      unique_id: discharge_limit_percentage
      unit_of_measurement: "%"
      icon: mdi:battery-arrow-down
      state: >
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set avg_price_cents = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}
        {% set avg_price = avg_price_cents / 100 %}
        {% set battery_soc = states('sensor.batterie_soc') | float(default=0) %}
        {% set car_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}

        {% if not car_charging %}
          100  {# No car charging: full discharge allowed #}
        {% elif current_price > (avg_price * 1.5) and battery_soc > 60 %}
          50  {# Very high prices + good battery: allow 50% discharge #}
        {% elif current_price > (avg_price * 1.2) and battery_soc > 40 %}
          30  {# High prices + decent battery: allow 30% discharge #}
        {% else %}
          10  {# Default during car charging: 10% limit #}
        {% endif %}

# Enhanced profitability calculation
- binary_sensor:
    - name: "Battery Charging Is Profitable Enhanced"
      unique_id: battery_charging_is_profitable_enhanced
      icon: mdi:cash-check
      state: >
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=999) %}
        {% set current_price_cents = current_price * 100 %}
        {% set max_price_24h = states('sensor.tibber_energy_highest_price_next_24_hours') | float(default=0) %}
        {% set avg_price_12h = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}

        {# System parameters #}
        {% set round_trip_efficiency = 0.90 %}
        {% set battery_wear_cost_cents = states('input_number.battery_wear_cost_per_kwh') | float(default=2) %}
        {% set min_spread_factor = 1.20 %}

        {# Calculate effective costs #}
        {% set effective_charge_cost = current_price_cents + battery_wear_cost_cents %}
        {% set effective_discharge_value = max_price_24h * round_trip_efficiency %}

        {# Profitability conditions #}
        {% set spread_sufficient = effective_discharge_value > (effective_charge_cost * min_spread_factor) %}
        {% set below_average = current_price_cents < (avg_price_12h * 0.85) %}

        {{ spread_sufficient and below_average }}

# Energy Flow Sensors for Visualization
- sensor:
    - name: "Grid Power"
      unique_id: grid_power_flow
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set main_meter = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {{ main_meter | round(0) }}

    - name: "Battery Power"
      unique_id: battery_power_flow
      icon: mdi:battery
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        
        {# Estimate battery power based on energy balance #}
        {# Positive = charging, Negative = discharging #}
        {% if charging_state == 'CHARGING' %}
          {% set battery_power = (grid_power + solar_power - ac_output) | abs %}
          {{ battery_power | round(0) }}
        {% elif charging_state == 'DISCHARGING' %}
          {% set battery_power = -(ac_output - solar_power - grid_power) %}
          {{ battery_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "House Consumption"
      unique_id: house_consumption_power
      icon: mdi:home
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        {% set wallbox_power = states('sensor.wattpilot_charging_power') | float(default=0) %}
        
        {# House consumption = Total AC output - Wallbox consumption #}
        {% set house_consumption = ac_output - wallbox_power %}
        {{ [house_consumption, 0] | max | round(0) }}

    - name: "Solar To Battery"
      unique_id: solar_to_battery_flow
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        
        {% if charging_state == 'CHARGING' %}
          {# Solar available for battery charging #}
          {{ [solar_power, 0] | max | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Solar To House"
      unique_id: solar_to_house_flow
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        {% set wallbox_power = states('sensor.wattpilot_charging_power') | float(default=0) %}
        
        {# Calculate house consumption to avoid circular dependency #}
        {% set house_consumption = [ac_output - wallbox_power, 0] | max %}
        
        {% if charging_state in ['DISCHARGING', 'HOLDING', 'OFF'] %}
          {# Solar goes to house consumption - take minimum of both #}
          {{ [solar_power, house_consumption] | min | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Solar To Grid"
      unique_id: solar_to_grid_flow
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        
        {% if grid_power < 0 %}
          {# Negative grid = export #}
          {{ (grid_power | abs) | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Battery To House"
      unique_id: battery_to_house_flow
      icon: mdi:battery-arrow-up
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set charging_state = states('sensor.charging_state') %}
        
        {# Calculate battery power directly to avoid circular dependency #}
        {% set solar_power = states('sensor.total_solar_power') | float(default=0) %}
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {% set ac_output = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        
        {% if charging_state == 'DISCHARGING' %}
          {# Battery power when discharging #}
          {% set battery_power = -(ac_output - solar_power - grid_power) %}
          {{ (battery_power | abs) | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Grid To House"
      unique_id: grid_to_house_flow
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {% set charging_state = states('sensor.charging_state') %}
        
        {% if grid_power > 0 and charging_state != 'CHARGING' %}
          {# Positive grid = import for house #}
          {{ grid_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Grid To Battery"
      unique_id: grid_to_battery_flow
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set grid_power = states('sensor.reading_energy_main_meter') | float(default=0) %}
        {% set charging_state = states('sensor.charging_state') %}
        
        {% if grid_power > 0 and charging_state == 'CHARGING' %}
          {# Grid charging battery #}
          {{ grid_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Wallbox Power"
      unique_id: wallbox_power_consumption
      icon: mdi:ev-station
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {# Wrap Wattpilot sensor for consistency with other flow sensors #}
        {# Allows for future processing (e.g., filtering, smoothing) if needed #}
        {{ states('sensor.wattpilot_charging_power') | float(default=0) | round(0) }}

    # Helper Power Sensors for Energy Integration (Riemann Sum)
    - name: "Grid Import Power"
      unique_id: grid_import_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.grid_power') | float(default=0) %}
        {% if p > 0 %} {{ p }} {% else %} 0 {% endif %}

    - name: "Grid Export Power"
      unique_id: grid_export_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.grid_power') | float(default=0) %}
        {% if p < 0 %} {{ p | abs }} {% else %} 0 {% endif %}

    - name: "Battery Charge Power"
      unique_id: battery_charge_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.battery_power') | float(default=0) %}
        {% set state = states('sensor.charging_state') %}
        {% if state == 'CHARGING' %} {{ p | abs }} {% else %} 0 {% endif %}

    - name: "Battery Discharge Power"
      unique_id: battery_discharge_power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {% set p = states('sensor.battery_power') | float(default=0) %}
        {% set state = states('sensor.charging_state') %}
        {% if state == 'DISCHARGING' %} {{ p | abs }} {% else %} 0 {% endif %}

# Sankey Chart Debug Sensors
# NOTE: Entity list is repeated in state and each attribute due to Home Assistant template limitations.
# When updating entities, update ALL occurrences of the list below.
- sensor:
    - name: "Sankey Battery Discharge"
      unique_id: sankey_battery_discharge
      icon: mdi:battery-arrow-down
      unit_of_measurement: W
      device_class: power
      state: >
        {% set battery_power = states('sensor.battery_power') | float(default=0) %}
        {% if battery_power < 0 %}
          {{ (battery_power | abs) | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Sankey Grid Import"
      unique_id: sankey_grid_import
      icon: mdi:transmission-tower
      unit_of_measurement: W
      device_class: power
      state: >
        {% set grid_power = states('sensor.grid_power') | float(default=0) %}
        {% if grid_power > 0 %}
          {{ grid_power | round(0) }}
        {% else %}
          0
        {% endif %}

    - name: "Sankey Entity Check"
      unique_id: sankey_entity_check
      icon: mdi:chart-sankey-variant
      state: >
        {# ENTITY LIST - Keep in sync across all attributes #}
        {% set entities = [
          'sensor.total_solar_power',
          'sensor.sankey_grid_import',
          'sensor.sankey_battery_discharge',
          'sensor.solar_to_house',
          'sensor.solar_to_battery',
          'sensor.solar_to_grid',
          'sensor.grid_to_house',
          'sensor.grid_to_battery',
          'sensor.battery_to_house',
          'sensor.house_consumption'
        ] %}
        {% set numeric_pattern = '^-?\\d+\\.?\\d*$' %}
        {% set ns = namespace(unavailable=[], invalid=[]) %}
        {% for entity in entities %}
          {% if states(entity) in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
            {% set ns.unavailable = ns.unavailable + [entity] %}
          {% elif not (states(entity) | regex_match(numeric_pattern)) %}
            {% set ns.invalid = ns.invalid + [entity] %}
          {% endif %}
        {% endfor %}
        {% if ns.unavailable | length > 0 or ns.invalid | length > 0 %}
          ERROR
        {% else %}
          OK
        {% endif %}
      attributes:
        unavailable_entities: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {% set ns = namespace(unavailable=[]) %}
          {% for entity in entities %}
            {% if states(entity) in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
              {% set ns.unavailable = ns.unavailable + [entity] %}
            {% endif %}
          {% endfor %}
          {{ ns.unavailable }}
        invalid_entities: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {% set numeric_pattern = '^-?\\d+\\.?\\d*$' %}
          {% set ns = namespace(invalid=[]) %}
          {% for entity in entities %}
            {% if states(entity) not in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
              {% if not (states(entity) | regex_match(numeric_pattern)) %}
                {% set ns.invalid = ns.invalid + [entity] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.invalid }}
        total_entities: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {{ entities | length }}
        available_count: >
          {# ENTITY LIST - Keep in sync across all attributes #}
          {% set entities = [
            'sensor.total_solar_power',
            'sensor.sankey_grid_import',
            'sensor.sankey_battery_discharge',
            'sensor.solar_to_house',
            'sensor.solar_to_battery',
            'sensor.solar_to_grid',
            'sensor.grid_to_house',
            'sensor.grid_to_battery',
            'sensor.battery_to_house',
            'sensor.house_consumption'
          ] %}
          {% set ns = namespace(available=0) %}
          {% for entity in entities %}
            {% if states(entity) not in ['unavailable', 'unknown', 'none', 'None', None, ''] %}
              {% set ns.available = ns.available + 1 %}
            {% endif %}
          {% endfor %}
          {{ ns.available }}

    - name: "Sankey Debug Info"
      unique_id: sankey_debug_info
      icon: mdi:information-outline
      state: >
        {% set check_state = states('sensor.sankey_entity_check') %}
        {% if check_state == 'OK' %}
          All entities operational
        {% else %}
          Check entities panel for issues
        {% endif %}
      attributes:
        entity_states: >
          {
            "total_solar_power": "{{ states('sensor.total_solar_power') }}",
            "grid_power": "{{ states('sensor.grid_power') }}",
            "battery_power": "{{ states('sensor.battery_power') }}",
            "solar_to_house": "{{ states('sensor.solar_to_house') }}",
            "solar_to_battery": "{{ states('sensor.solar_to_battery') }}",
            "solar_to_grid": "{{ states('sensor.solar_to_grid') }}",
            "grid_to_house": "{{ states('sensor.grid_to_house') }}",
            "grid_to_battery": "{{ states('sensor.grid_to_battery') }}",
            "battery_to_house": "{{ states('sensor.battery_to_house') }}",
            "house_consumption": "{{ states('sensor.house_consumption') }}"
          }
        diagnosis: >
          {% set unavailable = state_attr('sensor.sankey_entity_check', 'unavailable_entities') %}
          {% set invalid = state_attr('sensor.sankey_entity_check', 'invalid_entities') %}
          {% if unavailable | length > 0 %}
            ISSUE: {{ unavailable | length }} entities are unavailable. Check their source sensors.
          {% elif invalid | length > 0 %}
            ISSUE: {{ invalid | length }} entities have invalid values. Check template calculations.
          {% else %}
            All entities are available and have valid numeric values.
          {% endif %}
        recommendations: >
          {% set unavailable = state_attr('sensor.sankey_entity_check', 'unavailable_entities') %}
          {% if 'sensor.total_solar_power' in unavailable or 'sensor.fronius_solar_power' in unavailable %}
            - Check Fronius Modbus connection (IP: 192.168.178.92)
          {% endif %}
          {% if 'sensor.balkonkraftwerk_power' in unavailable %}
            - Check Deye inverter connection (IP: 192.168.178.78)
          {% endif %}
          {% if 'sensor.grid_power' in unavailable %}
            - Check sensor.reading_energy_main_meter availability
          {% endif %}
          {% if 'sensor.battery_power' in unavailable %}
            - Check charging_state and energy sensors
          {% endif %}
          {% if unavailable | length == 0 %}
            No issues detected. Sankey chart should display correctly.
          {% endif %}
