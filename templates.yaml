# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright (c) 2024, Julian Bartholomeyczik
# All rights reserved.

# Battery Status Sensors
- sensor:
    - name: "Batterie SoC"
      unique_id: 884c1888-1880-4e98-923c-795ff9264af2
      icon: mdi:home-battery-outline
      unit_of_measurement: "%"
      device_class: battery
      state: >
        {{ ((states('sensor.reading_energy_battery_soc_scaled') | float) * (10 ** -2 )) | round(0)}}

    - name: "Charging State"
      unique_id: adf7fd02-94ac-4565-8392-c3b9d3b0d2dc
      state: >
        {% set mapper =  {
              '1' : 'OFF',
              '2' : 'EMPTY',
              '3' : 'DISCHARGING',
              '4' : 'CHARGING',
              '5' : 'FULL',
              '6' : 'HOLDING',
              '7' : 'TESTING'} %}
        {% set state =  states('sensor.ChaSt') %}
        {{ mapper[state] if state in mapper else 'Unknown' }}

# Helper sensors for charging decision logic
- sensor:
    - name: "Battery SoC Threshold High"
      unique_id: battery_soc_threshold_high
      unit_of_measurement: "%"
      state: >
        {{ (states('input_number.soc_target_low_sun') | float(default=50)) - (states('input_number.soc_hist') | float(default=5)) }}

    - name: "Battery SoC Threshold Low"
      unique_id: battery_soc_threshold_low
      unit_of_measurement: "%"
      state: >
        {{ (states('input_number.soc_target_very_low_sun') | float(default=90)) - (states('input_number.soc_hist') | float(default=5)) }}

    - name: "Battery SoC Normalized"
      unique_id: battery_soc_normalized
      unit_of_measurement: "%"
      state: >
        {{ states('sensor.reading_energy_battery_soc_scaled') | float(default=0) / 100 }}

# Binary sensors for solar forecast conditions
- binary_sensor:
    - name: "Expected Sun Low"
      unique_id: expected_sun_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float(default=50000) <= states('input_number.sun_threshold_low') | float(default=15000) }}

    - name: "Expected Sun Very Low"
      unique_id: expected_sun_very_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_forecast_next_x_hours') | float(default=50000) <= states('input_number.sun_threshold_very_low') | float(default=8000) }}

    - name: "Charging Is Profitable"
      unique_id: charging_is_profitable
      icon: mdi:cash-check
      state: >
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set max_price_24h = states('sensor.tibber_energy_highest_price_next_24_hours') | float(default=0) %}
        {{ max_price_24h > (current_price * 1.15) }}

# Binary sensor for charging conditions
- binary_sensor:
    - name: "Should Start Charging"
      unique_id: should_start_charging
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float(default=0) %}
        {% set target_soc = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set automation_on = is_state('input_boolean.battery_automation_on', 'on') %}
        {% set charging_inactive = is_state('input_boolean.battery_charging_active', 'off') %}
        {% set hysteresis_buffer = states('input_number.soc_hist') | float(default=5) * 50 %}

        {# Check if car is charging - don't interfere with car protection #}
        {% set car_is_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}
        {% set car_protection_active = is_state('input_boolean.battery_no_discharging_active', 'on') %}

        {# Allow starting if: normal conditions met AND (car not charging OR car protection already handled) #}
        {% set basic_conditions = (current_soc < (target_soc - hysteresis_buffer)) and automation_on and charging_inactive %}
        {% set car_safe = not (car_is_charging and wallbox_not_eco and not car_protection_active) %}

        {{ basic_conditions and car_safe }}

    - name: "Should Stop Charging"
      unique_id: should_stop_charging
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float(default=0) %}
        {% set target_soc = states('input_number.battery_target_soc') | float(default=100) * 100 %}
        {% set computed_target_soc = states('sensor.computed_target_soc') | float(default=15) * 100 %}
        {% set charging_active = is_state('input_boolean.battery_charging_active', 'on') %}

        {# Hysteresis: multiply by 50 to convert % to scaled SoC units #}
        {% set hysteresis = states('input_number.soc_hist') | float(default=5) * 50 %}

        {# Stop charging when: #}
        {# 1. Battery reaches the original target plus hysteresis OR #}
        {# 2. Battery exceeds the current computed target (respond immediately when prices increase) #}
        {% set reached_target = current_soc >= (target_soc + hysteresis) %}
        {% set exceeds_computed_target = current_soc >= computed_target_soc %}

        {{ (reached_target or exceeds_computed_target) and charging_active }}

# Stable car charging detection with hysteresis
- binary_sensor:
    - name: "Car Charging Stable"
      unique_id: car_charging_stable
      device_class: battery_charging
      icon: mdi:ev-station
      state: >
        {% set is_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}

        {% if not (is_charging and wallbox_not_eco) %}
          {{ false }}
        {% else %}
          {# Check if state has been stable for 3 minutes #}
          {% set last_changed = as_timestamp(states.sensor.wattpilot_carconnected.last_changed) %}
          {% set now_ts = as_timestamp(now()) %}
          {% set stable_seconds = 180 %}
          {{ (now_ts - last_changed) >= stable_seconds }}
        {% endif %}

# Unified status sensor for monitoring
- sensor:
    - name: "Battery Control Status"
      unique_id: battery_control_status
      icon: mdi:state-machine
      state: >
        {% set charging = is_state('input_boolean.battery_charging_active', 'on') %}
        {% set discharge_limited = is_state('input_boolean.battery_no_discharging_active', 'on') %}
        {% set car_charging = is_state('binary_sensor.car_charging_stable', 'on') %}

        {% if charging and discharge_limited %}
          Charging (Car Protection Active)
        {% elif charging %}
          Charging (Normal)
        {% elif discharge_limited %}
          Discharge Limited (Car Charging)
        {% elif car_charging %}
          Car Charging (Waiting for Stable State)
        {% else %}
          Normal
        {% endif %}

# Computed target SoC sensor
- sensor:
    - name: "Computed Target SoC"
      unique_id: computed_target_soc
      unit_of_measurement: "%"
      state: >
        {% set percentile = states('sensor.tibber_energy_price_percentile_next_12_hours') | float(default=100) %}
        {% set expected_sun_very_low = is_state('binary_sensor.expected_sun_very_low', 'on') %}
        {% set expected_sun_low = is_state('binary_sensor.expected_sun_low', 'on') %}

        {# Profitability Check: Max Price > Current Price * 1.15 #}
        {# Note: tibber_energy_prices is in EUR, others in Cents. Convert to Cents. #}
        {% set current_price_eur = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set current_price_cents = current_price_eur * 100 %}
        {% set max_price_24h = states('sensor.tibber_energy_highest_price_next_24_hours') | float(default=0) %}
        {% set is_profitable = is_state('binary_sensor.battery_charging_is_profitable_enhanced', 'on') %}

        {# Trend Check: Don't charge if price is falling (next hour is cheaper) #}
        {% set next_price_cents = states('sensor.tibber_energy_price_next_hour') | float(default=999) %}
        {% set is_falling = next_price_cents < current_price_cents %}
        {% if not is_profitable %}
          {{ states('input_number.soc_target_default') | float(default=15) }}
        {% elif percentile <= 25 and not is_falling %}
          {# Cheap Energy: Fill based on Sun Forecast #}
          {% if expected_sun_very_low %}
            100
          {% elif expected_sun_low %}
            70
          {% else %}
            {{ states('input_number.soc_target_default') | float(default=15) }}
          {% endif %}
        {% elif percentile <= 50 and expected_sun_very_low and not is_falling %}
          {# Moderate Price + Very Low Sun: Top up a bit #}
          60
        {% else %}
          {{ states('input_number.soc_target_default') | float(default=15) }}
        {% endif %}

# Balcony Power Plant (Balkonkraftwerk) Sensors
- sensor:
    - name: "Balkonkraftwerk Power"
      unique_id: balkonkraftwerk_power
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      state: >
        {{ states('sensor.inverter_power') | float(default=0) }}

    - name: "Balkonkraftwerk Daily Energy"
      unique_id: balkonkraftwerk_daily_energy
      icon: mdi:solar-panel
      unit_of_measurement: kWh
      device_class: energy
      state_class: total_increasing
      state: >
        {{ states('sensor.inverter_daily_energy') | float(default=0) }}

    - name: "Balkonkraftwerk Status"
      unique_id: balkonkraftwerk_status
      icon: mdi:state-machine
      state: >
        {% set power = states('sensor.inverter_power') | float(default=0) %}
        {% if power > 10 %}
          Producing
        {% elif power > 0 %}
          Idle
        {% else %}
          Offline
        {% endif %}

- binary_sensor:
    - name: "Balkonkraftwerk Online"
      unique_id: balkonkraftwerk_online
      device_class: connectivity
      state: >
        {% set power = states('sensor.inverter_power') %}
        {{ power not in ['unavailable', 'unknown', 'None'] }}

# Fronius Solar Production Sensors
- sensor:

    - name: "Fronius Solar Power"
      unique_id: fronius_solar_power
      icon: mdi:solar-power
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      availability: >
        {{ states('sensor.reading_energy_inverter_ac_output') not in ['unavailable', 'unknown', 'None'] }}
      state: >
        {{ states('sensor.reading_energy_inverter_ac_output') | float(default=0) | round(0) | max(0) }}

    - name: "Total Solar Power"
      unique_id: total_solar_power
      icon: mdi:solar-power-variant
      unit_of_measurement: W
      device_class: power
      state_class: measurement
      availability: >
        {{ states('sensor.fronius_solar_power') not in ['unavailable', 'unknown', 'None'] 
           or states('sensor.inverter_power') not in ['unavailable', 'unknown', 'None'] }}
      state: >
        {% set fronius = states('sensor.fronius_solar_power') | float(default=0) %}
        {% set deye = states('sensor.inverter_power') | float(default=0) %}
        {{ (fronius + deye) | round(0) }}

    - name: "Fronius Solar Status"
      unique_id: fronius_solar_status
      icon: mdi:state-machine
      availability: >
        {{ states('sensor.reading_energy_inverter_ac_output') not in ['unavailable', 'unknown', 'None'] }}
      state: >
        {% set power = states('sensor.reading_energy_inverter_ac_output') | float(default=0) %}
        {% if power > 50 %}
          Producing
        {% elif power > 0 %}
          Low Production
        {% else %}
          Offline
        {% endif %}

- binary_sensor:
    - name: "Fronius Solar Online"
      unique_id: fronius_solar_online
      device_class: connectivity
      state: >
        {% set power = states('sensor.reading_energy_inverter_ac_output') %}
        {{ power not in ['unavailable', 'unknown', 'None'] }}

# Unified battery control mode coordinator
- sensor:
    - name: "Battery Control Mode"
      unique_id: battery_control_mode
      icon: mdi:state-machine
      state: >
        {% set car_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}
        {% set wallbox_not_eco = not is_state('select.wattpilot_charging_mode', 'Eco') %}
        {% set should_charge = is_state('binary_sensor.should_start_charging', 'on') %}
        {% set automation_on = is_state('input_boolean.battery_automation_on', 'on') %}
        {% set manual_charge = is_state('input_boolean.manual_battery_charge', 'on') %}
        {% set should_charge_during_car = is_state('binary_sensor.should_charge_battery_during_car_charging', 'on') %}

        {# Priority order: Manual > Car+Battery > Car Only > Battery > Normal #}
        {% if manual_charge %}
          manual_charging
        {% elif car_charging and wallbox_not_eco and automation_on %}
          {% if should_charge and should_charge_during_car %}
            car_and_battery_charging
          {% else %}
            car_charging_only
          {% endif %}
        {% elif should_charge and automation_on %}
          battery_charging
        {% else %}
          normal
        {% endif %}

# Smart decision for charging battery during car charging
- binary_sensor:
    - name: "Should Charge Battery During Car Charging"
      unique_id: should_charge_battery_during_car_charging
      icon: mdi:ev-station
      state: >
        {% set car_power = states('sensor.wattpilot_charging_power') | float(default=0) %}
        {% set home_power = states('sensor.home_consumption_power') | float(default=2000) %}
        {% set battery_charge_rate = states('input_number.battery_charge_rate_max') | float(default=5000) %}
        {% set grid_capacity = states('input_number.grid_connection_capacity') | float(default=20000) %}
        {% set current_price_cents = states('sensor.tibber_energy_prices') | float(default=999) * 100 %}
        {% set avg_price = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}

        {% set total_load = car_power + home_power + battery_charge_rate %}
        {% set load_ok = total_load < (grid_capacity * 0.9) %}
        {% set price_very_low = current_price_cents < (avg_price * 0.8) %}

        {{ load_ok and price_very_low }}

# Dynamic discharge limit based on price and battery level
- sensor:
    - name: "Discharge Limit Percentage"
      unique_id: discharge_limit_percentage
      unit_of_measurement: "%"
      icon: mdi:battery-arrow-down
      state: >
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set avg_price = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) / 100 %}
        {% set battery_soc = states('sensor.batterie_soc') | float(default=0) %}
        {% set car_charging = is_state('sensor.wattpilot_carconnected', 'charging') %}

        {% if not car_charging %}
          100  {# No car charging: full discharge allowed #}
        {% elif current_price > (avg_price * 1.5) and battery_soc > 60 %}
          50  {# Very high prices + good battery: allow 50% discharge #}
        {% elif current_price > (avg_price * 1.2) and battery_soc > 40 %}
          30  {# High prices + decent battery: allow 30% discharge #}
        {% else %}
          10  {# Default during car charging: 10% limit #}
        {% endif %}

# Enhanced profitability calculation
- binary_sensor:
    - name: "Battery Charging Is Profitable Enhanced"
      unique_id: battery_charging_is_profitable_enhanced
      icon: mdi:cash-check
      state: >
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=999) %}
        {% set current_price_cents = current_price * 100 %}
        {% set max_price_24h = states('sensor.tibber_energy_highest_price_next_24_hours') | float(default=0) %}
        {% set avg_price_12h = states('sensor.tibber_energy_average_price_next_12_hours') | float(default=999) %}

        {# System parameters #}
        {% set round_trip_efficiency = 0.90 %}
        {% set battery_wear_cost_cents = states('input_number.battery_wear_cost_per_kwh') | float(default=2) %}
        {% set min_spread_factor = 1.20 %}

        {# Calculate effective costs #}
        {% set effective_charge_cost = current_price_cents + battery_wear_cost_cents %}
        {% set effective_discharge_value = max_price_24h * round_trip_efficiency %}

        {# Profitability conditions #}
        {% set spread_sufficient = effective_discharge_value > (effective_charge_cost * min_spread_factor) %}
        {% set below_average = current_price_cents < (avg_price_12h * 0.85) %}

        {{ spread_sufficient and below_average }}
