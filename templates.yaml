# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright (c) 2024, Julian Bartholomeyczik
# All rights reserved.

# Battery Status Sensors
- sensor:
    - name: "Batterie SoC"
      unique_id: 884c1888-1880-4e98-923c-795ff9264af2
      icon: mdi:home-battery-outline
      unit_of_measurement: "%"
      device_class: battery
      state: >
        {{ ((states('sensor.reading_energy_battery_soc_scaled') | float) * (10 ** -2 )) | round(0)}}
    
    - name: "Charging State"
      unique_id: adf7fd02-94ac-4565-8392-c3b9d3b0d2dc
      state: >
        {% set mapper =  {
              '1' : 'OFF',
              '2' : 'EMPTY',
              '3' : 'DISCHARGING',
              '4' : 'CHARGING',
              '5' : 'FULL',
              '6' : 'HOLDING',
              '7' : 'TESTING'} %}
        {% set state =  states('sensor.ChaSt') %}
        {{ mapper[state] if state in mapper else 'Unknown' }}

# Helper sensors for charging decision logic
- sensor:
    - name: "Battery SoC Threshold High"
      unique_id: battery_soc_threshold_high
      unit_of_measurement: "%"
      state: >
        {{ (states('input_number.soc_target_low_sun') | float) - (states('input_number.soc_hist') | float) }}
    
    - name: "Battery SoC Threshold Low"
      unique_id: battery_soc_threshold_low
      unit_of_measurement: "%"
      state: >
        {{ (states('input_number.soc_target_very_low_sun') | float) - (states('input_number.soc_hist') | float) }}
    
    - name: "Battery SoC Normalized"
      unique_id: battery_soc_normalized
      unit_of_measurement: "%"
      state: >
        {{ states('sensor.reading_energy_battery_soc_scaled') | float / 100 }}

# Binary sensors for solar forecast conditions
- binary_sensor:
    - name: "Expected Sun Low"
      unique_id: expected_sun_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_prognose_verbleibende_leistung_heute') | float <= states('input_number.sun_threshold_low') | float }}
    
    - name: "Expected Sun Very Low"
      unique_id: expected_sun_very_low
      device_class: power
      state: >
        {{ states('sensor.solcast_pv_forecast_forecast_next_x_hours') | float <= states('input_number.sun_threshold_very_low') | float }}

# Binary sensor for charging conditions
- binary_sensor:
    - name: "Should Start Charging"
      unique_id: should_start_charging
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float %}
        {% set target_soc = states('sensor.computed_target_soc') | float * 100 %}
        {% set automation_on = is_state('input_boolean.battery_automation_on', 'on') %}
        {% set charging_inactive = is_state('input_boolean.battery_charging_active', 'off') %}
        
        {# Hysteresis buffer: divide by 200 to convert % to fractional buffer (e.g., 5% -> 0.025) #}
        {# We use a scaled comparison here. Target SoC is in %, Current is scaled (100% = 10000) #}
        {# So Target 80% = 80. Current 80% = 8000. #}
        {# Let's convert Target to Scaled: Target * 100 #}
        
        {% set hysteresis_buffer = states('input_number.soc_hist') | float * 50 %}
        
        {{ (current_soc < (target_soc - hysteresis_buffer)) and automation_on and charging_inactive }}
    
    - name: "Should Stop Charging"
      unique_id: should_stop_charging
      state: >
        {% set current_soc = states('sensor.reading_energy_battery_soc_scaled') | float %}
        {% set target_soc = states('input_number.battery_target_soc') | float * 100 %}
        {% set charging_active = is_state('input_boolean.battery_charging_active', 'on') %}
        
        {# Hysteresis: multiply by 50 to convert % to scaled SoC units #}
        {% set hysteresis = states('input_number.soc_hist') | float * 50 %}
        
        {# Stop charging when target is reached plus hysteresis buffer #}
        {{ (current_soc >= (target_soc + hysteresis)) and charging_active }}

# Computed target SoC sensor
- sensor:
    - name: "Computed Target SoC"
      unique_id: computed_target_soc
      unit_of_measurement: "%"
      state: >
        {% set percentile = states('sensor.tibber_energy_price_percentile_next_12_hours') | float(default=100) %}
        {% set expected_sun_very_low = is_state('binary_sensor.expected_sun_very_low', 'on') %}
        {% set expected_sun_low = is_state('binary_sensor.expected_sun_low', 'on') %}
        
        {# Profitability Check: Max Price > Current Price * 1.15 #}
        {% set current_price = states('sensor.tibber_energy_prices') | float(default=0) %}
        {% set max_price_24h = states('sensor.tibber_energy_highest_price_next_24_hours') | float(default=0) %}
        {% set is_profitable = max_price_24h > (current_price * 1.15) %}
        
        {% if not is_profitable %}
          {{ states('input_number.soc_target_default') | float }}
        {% elif percentile <= 25 %}
          {# Cheap Energy: Fill based on Sun Forecast #}
          {% if expected_sun_very_low %}
            100
          {% elif expected_sun_low %}
            70
          {% else %}
            {{ states('input_number.soc_target_default') | float }}
          {% endif %}
        {% elif percentile <= 50 and expected_sun_very_low %}
          {# Moderate Price + Very Low Sun: Top up a bit #}
          60
        {% else %}
          {{ states('input_number.soc_target_default') | float }}
        {% endif %}
