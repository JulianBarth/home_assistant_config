# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright (c) 2024, Julian Bartholomeyczik
# All rights reserved.
# Using 15-minute pricing intervals from Tibber API
- alias: "Manual Battery Charging"
  trigger:
    - platform: state
      entity_id: input_boolean.manual_battery_charge
      to: "on"
  action:
    # Just set the flag - let unified coordinator handle the rest
    - service: notify.mobile_app_f4gdn4ry0gpq_2
      data:
        message: "Manual battery charging requested. System will override automation."
        title: "Battery Control"

- alias: "Unified Battery Control Coordinator"
  description: "Single automation to coordinate all battery control modes"
  trigger:
    # Trigger on mode changes
    - platform: state
      entity_id: sensor.battery_control_mode
    # Trigger on SoC changes (for stop conditions and hold mode)
    - platform: state
      entity_id:
        - binary_sensor.should_stop_charging
        - binary_sensor.should_hold_battery_soc
        - binary_sensor.should_prevent_discharge
        - sensor.computed_target_soc
    # Fallback check every 5 minutes
    - platform: time_pattern
      minutes: "/5"
  action:
    - choose:
        # Mode 1: Manual Charging (Highest Priority)
        - conditions:
            - condition: state
              entity_id: sensor.battery_control_mode
              state: "manual_charging"
          sequence:
            - service: input_number.set_value
              target:
                entity_id: input_number.battery_target_soc
              data:
                value: "{{ states('input_number.manual_charge_target_soc') | float(default=80) }}"
            - service: script.turn_on
              target:
                entity_id: script.forced_full_recharge
            - service: switch.turn_on
              target:
                entity_id: switch.StorCtl_Mod
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.battery_charging_active

        # Mode 2: Car + Battery Charging
        - conditions:
            - condition: state
              entity_id: sensor.battery_control_mode
              state: "car_and_battery_charging"
            - condition: state
              entity_id: binary_sensor.should_stop_charging
              state: "off"
          sequence:
            - service: input_number.set_value
              target:
                entity_id: input_number.battery_target_soc
              data:
                value: "{{ states('sensor.computed_target_soc') | float(default=15) }}"
            - service: script.turn_on
              target:
                entity_id: script.charge_battery_limit_discharge

        # Mode 3: Car Charging Only (Limit Discharge)
        - conditions:
            - condition: state
              entity_id: sensor.battery_control_mode
              state: "car_charging_only"
          sequence:
            - service: script.turn_on
              target:
                entity_id: script.set_dynamic_discharge_limit
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.battery_no_discharging_active

        # Mode 4: Battery Charging Only
        - conditions:
            - condition: state
              entity_id: sensor.battery_control_mode
              state: "battery_charging"
            - condition: state
              entity_id: binary_sensor.should_stop_charging
              state: "off"
          sequence:
            - service: input_number.set_value
              target:
                entity_id: input_number.battery_target_soc
              data:
                value: "{{ states('sensor.computed_target_soc') | float(default=15) }}"
            - service: script.turn_on
              target:
                entity_id: script.forced_full_recharge
            - service: switch.turn_on
              target:
                entity_id: switch.StorCtl_Mod
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.battery_charging_active

      # Default: Normal Operation or Stop Charging or Hold SOC or Prevent Discharge
      default:
        - choose:
            # Check if we should hold battery SOC at target (gradual slowdown)
            - conditions:
                - condition: state
                  entity_id: binary_sensor.should_hold_battery_soc
                  state: "on"
                # Double-check charging is still active
                - condition: state
                  entity_id: input_boolean.battery_charging_active
                  state: "on"
                # Prevent re-executing if already in hold mode
                - condition: state
                  entity_id: input_boolean.battery_no_discharging_active
                  state: "off"
              sequence:
                # Use reduced charge rate (50%) to approach target gradually
                - service: script.turn_on
                  target:
                    entity_id: script.charge_battery_reduced_rate
                # Set flag to indicate we're in hold/limited discharge mode
                - service: input_boolean.turn_on
                  target:
                    entity_id: input_boolean.battery_no_discharging_active
            # NEW: Prevent discharge when at target SoC (keep battery at desired level)
            - conditions:
                - condition: state
                  entity_id: binary_sensor.should_prevent_discharge
                  state: "on"
              sequence:
                # Use limited discharge script to prevent draining
                - service: script.turn_on
                  target:
                    entity_id: script.set_limited_discharge
                - service: switch.turn_on
                  target:
                    entity_id: switch.StorCtl_Mod
                # Set flag for state consistency (Bug 2 fix)
                - service: input_boolean.turn_on
                  target:
                    entity_id: input_boolean.battery_no_discharging_active
            # Check if we should stop charging
            - conditions:
                - condition: state
                  entity_id: binary_sensor.should_stop_charging
                  state: "on"
              sequence:
                - service: script.turn_on
                  target:
                    entity_id: script.stop_battery_charging
                - service: input_boolean.turn_off
                  target:
                    entity_id: input_boolean.manual_battery_charge
                # Clear both flags â€” prevent_discharge sensor handles ongoing protection
                - service: input_boolean.turn_off
                  target:
                    entity_id:
                      - input_boolean.battery_charging_active
                      - input_boolean.battery_no_discharging_active
                # Reset target to default (prevents stale 100% target from previous cycle)
                - service: input_number.set_value
                  target:
                    entity_id: input_number.battery_target_soc
                  data:
                    value: "{{ states('input_number.soc_target_default') | float(default=15) }}"
          # Normal operation - release controls only when appropriate
          default:
            - choose:
                # If we should still prevent discharge, maintain the lock
                - conditions:
                    - condition: state
                      entity_id: binary_sensor.should_prevent_discharge
                      state: "on"
                  sequence:
                    # Keep discharge limited but turn off charging
                    - service: script.turn_on
                      target:
                        entity_id: script.set_limited_discharge
                    - service: switch.turn_on
                      target:
                        entity_id: switch.StorCtl_Mod
                    - service: input_boolean.turn_off
                      target:
                        entity_id: input_boolean.battery_charging_active
              # Fully release controls only when prevent_discharge is off
              default:
                - service: script.turn_on
                  target:
                    entity_id: script.set_regular_charge
                - service: switch.turn_off
                  target:
                    entity_id: switch.StorCtl_Mod
                - service: input_boolean.turn_off
                  target:
                    entity_id:
                      - input_boolean.battery_charging_active
                      - input_boolean.battery_no_discharging_active
                # Reset target to default
                - service: input_number.set_value
                  target:
                    entity_id: input_number.battery_target_soc
                  data:
                    value: "{{ states('input_number.soc_target_default') | float(default=15) }}"
- alias: Solcast update
  description: ""
  trigger:
    - platform: state
      entity_id: binary_sensor.solcast_update_due
      to: "on"
  condition:
    - condition: sun
      before: sunset
      after: sunrise
  action:
    - delay:
        seconds: "{{ range(30, 360)|random|int }}"
    - service: solcast_solar.update_forecasts
      data: {}
  mode: single

- alias: "Notify when Battery Charging is Active"
  trigger:
    - platform: state
      entity_id: input_boolean.battery_charging_active
      to: "on"
  action:
    - service: notify.mobile_app_f4gdn4ry0gpq_2
      data:
        message: "Battery Charging is now Active."
        title: "Battery Alert"
- alias: "Notify when No Battery Discharging is Active"
  trigger:
    - platform: state
      entity_id: input_boolean.battery_no_discharging_active
      to: "on"
  action:
    - service: notify.mobile_app_f4gdn4ry0gpq_2
      data:
        message: "Battery Discharging is Disabled."
        title: "Battery Alert"
- alias: "Notify when Battery SoC is below 7.5%"
  trigger:
    - platform: numeric_state
      entity_id: sensor.reading_energy_battery_soc_scaled
      below: 750  # Adjust if your SoC is scaled differently (e.g., 7.5% is 750)
  action:
    - service: notify.mobile_app_f4gdn4ry0gpq_2
      data:
        message: "Battery SoC is below 7.5%!"
        title: "Battery Alert"

- alias: "Notify when Tibber Pulse is not functioning"
  trigger:
    - platform: state
      entity_id: binary_sensor.tibber_pulse_not_functioning
      to: "on"
      for:
        minutes: 5  # Wait 5 minutes to avoid false alarms from brief disconnections
  action:
    - service: notify.mobile_app_f4gdn4ry0gpq_2
      data:
        message: "Tibber Pulse sensor is not functioning. Please check the sensor battery or connectivity."
        title: "Tibber Pulse Alert"

# =============================================================================
# ALGORITHM STATE LOGGER
# Writes a JSON line to /config/battery_algorithm.log every 15 min and on events
# =============================================================================
- alias: "Battery Algorithm State Logger"
  description: "Logs full algorithm state as JSON for offline analysis"
  trigger:
    # Periodic: every 15 minutes
    - platform: time_pattern
      minutes: "/15"
      id: periodic
    # Event-based triggers
    - platform: state
      entity_id: input_boolean.battery_charging_active
      id: charging_flag_changed
    - platform: state
      entity_id: input_boolean.battery_no_discharging_active
      id: discharge_flag_changed
    - platform: state
      entity_id: binary_sensor.should_start_charging
      to: "on"
      id: should_start
    - platform: state
      entity_id: binary_sensor.should_stop_charging
      to: "on"
      id: should_stop
    - platform: state
      entity_id: sensor.battery_control_mode
      id: mode_changed
  action:
    - service: notify.battery_log
      data:
        message: >
          {% set data = state_attr('sensor.battery_optimization_data', 'calculation_data') %}
          {% set today = state_attr('sensor.tibber_energy_prices', 'today') %}
          {% set tomorrow = state_attr('sensor.tibber_energy_prices', 'tomorrow') %}
          {"ts":"{{ now().isoformat() }}","trigger":"{{ trigger.id | default('unknown') }}","soc":{{ states('sensor.batterie_soc') | float(0) }},"soc_scaled":{{ states('sensor.reading_energy_battery_soc_scaled') | float(0) }},"target":{{ states('input_number.battery_target_soc') | float(15) }},"computed_target":{{ states('sensor.computed_target_soc') | float(15) }},"mode":"{{ states('sensor.battery_control_mode') }}","charging_state":"{{ states('sensor.charging_state') }}","bridge_type":"{{ data.bridge_type if data else 'N/A' }}","bridge_hours":{{ data.bridge_hours if data else 0 }},"bridge_consumption_wh":{{ data.bridge_consumption_wh if data else 0 }},"energy_deficit_wh":{{ data.energy_deficit_wh if data else 0 }},"solar_remaining_wh":{{ data.expected_solar_wh if data else 0 }},"usable_solar_wh":{{ data.usable_solar_wh if data else 0 }},"is_low_solar":{{ data.is_low_solar_day | lower if data else 'true' }},"price_ct":{{ (states('sensor.tibber_energy_prices') | float(0) * 100) | round(2) }},"next_price_ct":{{ data.next_price_cents if data else 0 }},"price_drop_ct":{{ data.price_drop_cents if data else 0 }},"percentile":{{ states('sensor.tibber_energy_price_percentile_next_12_hours') | float(100) }},"max_price_ct":{{ states('input_number.max_charge_price_cents') | float(25) }},"decision":"{{ data.decision_reason if data else 'N/A' }}","flags":{"charging":{{ is_state('input_boolean.battery_charging_active','on') | lower }},"no_discharge":{{ is_state('input_boolean.battery_no_discharging_active','on') | lower }},"automation":{{ is_state('input_boolean.battery_automation_on','on') | lower }},"manual":{{ is_state('input_boolean.manual_battery_charge','on') | lower }}},"sensors":{"start":{{ is_state('binary_sensor.should_start_charging','on') | lower }},"stop":{{ is_state('binary_sensor.should_stop_charging','on') | lower }},"hold":{{ is_state('binary_sensor.should_hold_battery_soc','on') | lower }},"prevent":{{ is_state('binary_sensor.should_prevent_discharge','on') | lower }},"profitable":{{ is_state('binary_sensor.battery_charging_is_profitable_enhanced','on') | lower }},"car":{{ is_state('binary_sensor.car_charging_stable','on') | lower }}},"inverter":{"battery_w":{{ states('sensor.battery_power') | float(0) | round(0) }},"ac_w":{{ states('sensor.reading_energy_inverter_ac_output') | float(0) | round(0) }},"grid_w":{{ states('sensor.reading_energy_main_meter') | float(0) | round(0) }},"storctl":"{{ states('switch.storctl_mod') }}"},"prices":{"today":{{ today | length if today else 0 }},"tomorrow":{{ tomorrow | length if tomorrow else 0 }}}}
  mode: queued
  max: 5

